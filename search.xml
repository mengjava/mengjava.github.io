<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2019%2F01%2F28%2Fmysql%2F</url>
    <content type="text"><![CDATA[1.一般应急调优的思路：123456789101112131、show processlistSHOW PROCESSLIST显示哪些线程正在运行show processlist 详细介绍2、查看执行计划 查看索引3、通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题4、show status like &apos;%lock%&apos;; # 查询锁状态 kill SESSION_ID; # 杀掉有问题的session 2.常规调优思路：针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。1234567891、查看slowlog，分析slowlog，分析出查询慢的语句。慢查询具体操作2、按照一定优先级，进行一个一个的排查所有慢语句。3、分析top sql，进行explain调试，查看语句执行时间。4、调整索引或语句本身。 3.什么情况下不走索引123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因 2. 字符串与数字比较不使用索引; CREATE TABLE `a` (`a` char(10)); EXPLAIN SELECT * FROM `a` WHERE `a`=&quot;1&quot; -- 走索引 EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引 select * from dept where dname=&apos;xxx&apos; or loc=&apos;xx&apos; or deptno=45 --如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or 关键字 3. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引4.前导模糊查询不能使用索引如:select name from user where name like &apos;%zhangsan&apos;非前导则可以:select name from user where name like &apos;zhangsan%&apos;建议可以考虑使用 Lucene 等全文索引工具来代替频繁的模糊查询。5.负向查询不能使用索引select name from user where id not in (1,3,4);应该修改为:select name from user where id in (2,5,6);6.在字段上进行计算不能命中索引select name from user where FROM_UNIXTIME(create_time) &lt; CURDATE();应该修改为:select name from user where create_time &lt; FROM_UNIXTIME(CURDATE());7.最左前缀问题如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:select username from user where username=&apos;zhangsan&apos; and pwd =&apos;axsedf1sd&apos;select username from user where pwd =&apos;axsedf1sd&apos; and username=&apos;zhangsan&apos;select username from user where username=&apos;zhangsan&apos;但是使用select username from user where pwd =&apos;axsedf1sd&apos;是不能命中索引的。8. 如果明确知道只有一条记录返回select name from user where username=&apos;zhangsan&apos; limit 1可以提高效率，可以让数据库停止游标移动。9.不要让数据库帮我们做强制类型转换select name from user where telno=18722222222这样虽然可以查出数据，但是会导致全表扫描。需要修改为select name from user where telno=&apos;18722222222&apos;10.如果需要进行 join 的字段两表的字段类型要相同不然也不会命中索引。 4.索引选择原则123456781. 较频繁的作为查询条件的字段应该创建索引2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件3. 更新非常频繁的字段不适合创建索引4. 不会出现在 WHERE 子句中的字段不该创建索引5. 数据区分不明显的不建议创建索引如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。字段的默认值不要为 null这样会带来和预期不一致的查询结果。]]></content>
      <categories>
        <category>mysql性能优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Face++行驶证OCR识别]]></title>
    <url>%2F2018%2F12%2F24%2Fface%2F</url>
    <content type="text"><![CDATA[官方API地址为: https://console.faceplusplus.com.cn/documents/5671706首先创建自己的账号 生成api_key api_secret 具体代码如下123456789101112131415161718public String ocrVehicleLicenseOrMergeFace(@RequestParam(&quot;imageUrl&quot;) String imageUrl,@RequestParam(&quot;group&quot;) String group,@RequestParam(&quot;type&quot;) Integer type) throws IOException &#123; String image_url=FILE_INNER_URL+group+&quot;/&quot;+imageUrl; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost uploadFile = new HttpPost(LICENSE_URL); MultipartEntityBuilder builder = MultipartEntityBuilder.create(); builder.addTextBody(&quot;api_key&quot;, API_KEY, ContentType.TEXT_PLAIN); builder.addTextBody(&quot;api_secret&quot;, API_SECRET, ContentType.TEXT_PLAIN); builder.addTextBody(&quot;image_url&quot;, image_url, ContentType.TEXT_PLAIN); // 把文件加到HTTP的post请求中 HttpEntity multipart = builder.build(); uploadFile.setEntity(multipart); CloseableHttpResponse response = httpClient.execute(uploadFile); HttpEntity responseEntity = response.getEntity(); //转换值 String sResponse = EntityUtils.toString(responseEntity, &quot;UTF-8&quot;); LicenseResult licenseResult = JSONObject.parseObject(sResponse, LicenseResult.class); return JSONUtil.toJsonStringSUSSESS(&quot;查询成功&quot;, licenseResult); &#125;]]></content>
      <categories>
        <category>Face++</category>
      </categories>
      <tags>
        <tag>行驶证OCR识别</tag>
        <tag>Face++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公平锁与非公平锁]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%2F</url>
    <content type="text"><![CDATA[在ReentrantLock中很明显可以看到其中同步包括两种，分别是公平的FairSync 和非公平的 NonfairSync。公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 默认情况下ReentrantLock是通过非公平锁来进行同步的，包括synchronized关键字都是如此，因为这样性能会更好。因为从线程进入了Runnable状态，可以执行开始，到实际线程执行是要比较久的时间的。而且，在一个锁释放之后，其他的线程会需要重新来获取锁。其中经历了持有锁的线程释放锁，其他线程从挂起恢复到Runnable状态，其他线程请求锁，获得锁，线程执行，这一系列步骤。如果这个时候，存在一个线程直接请求锁，可能就避开挂起到恢复Runnable状态的这段消耗，所以性能更优化。1234567/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125; 默认状态，使用的ReentrantLock()就是非公平锁。再参考如下代码，我们知道ReentrantLock的获取锁的操作是通过装饰模式代理给sync的。 1234567891011121314151617/** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */public void lock() &#123; sync.lock();&#125; 下面参考一下FairSync和NonfairSync对lock方法的实现： 12345678910111213141516171819202122232425/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125;&#125;/** * Sync object for fair locks */static final class FairSync extends Sync &#123; final void lock() &#123; acquire(1); &#125;&#125; 当使用非公平锁的时候，会立刻尝试配置状态，成功了就会插队执行，失败了就会和公平锁的机制一样，调用acquire()方法，以排他的方式来获取锁，成功了立刻返回，否则将线程加入队列，知道成功调用为止。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>公平锁</tag>
        <tag>非公平锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Mac和Windows上同时写Hexo博客？]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%A6%82%E4%BD%95%E5%9C%A8mac%E5%92%8CWindows%E4%B8%8A%E5%90%8C%E6%97%B6%E5%86%99hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先，我是在公司上的windows机器上部署了hexo，但是回家后发现很不方便，家里的电脑是mac机。所以根据网上的经验我总结了一下如何在mac和Windows上同时写hexo博客。 Windows机器这是我在公司的机器，本来以为不同系统会很麻烦，弄完发现一点也不麻烦。 在github上新建远程仓库将原来的page项目删除，新建一个和原来名字一样的空项目。不用初始化README.md 此时只有一个空的master分支。 本地初始化一个Hexo项目注意：本地的目录不要动 重新新建一个空目录，作为你的博客目录。进入该目录，右击Git bash here，初始化一个Hexo项目：123hexo initnpm installnpm install hexo-deployer-git --save 然后用自己原来博客里的文件替换掉这里的source\, scaffolds\, themes\,_config.yml替换成自己原来博客里的。 注意，这里把themes/next中的.git/目录删除 将整个目录推送到master要推送到master分支，首先要将该目录初始化为本地Git仓库： 123456git init//把博客目录下所有文件推送到master分支git remote add origin xxgit add .git commit -m &quot;first add hexo source code&quot;git push origin master 注意：如果不小心初始化了README.md 在执行 git push origin master 会失败.。此时先执行以下命令进行代码合并 1git push origin master 在github上新建一个分支1.创建本地分支 git branch 分支名，例如：git branch hexo 2.切换本地分支 git checkout 分支名，例如从master切换到分支：git checkout hexo 3.远程分支就是本地分支push到服务器上。比如master就是一个最典型的远程分支（默认）。 git push origin hexo 4.设置默认分支 git branch --set-upstream-to=origin/hexo hexo 新建一个分支hexo(名字可以自定义)，这时候hexo分支和master分支的内容一样，都是hexo的源文件。并把hexo设为默认分支，这样的话在另外一台机器上克隆下来就直接进入hexo分支，并且以后所有操作都是在hexo分支下完成。 为什么需要这个额外的分支呢？ 因为hexo d只把静态网页文件部署到master分支上，所以你换了另外一台电脑，就无法pull下来继续写博客了。有了hexo分支的话，就可以把hexo分支中的源文件(配置文件、主题样式等)pull下来，再hexo g的话就可以生成一模一样的静态文件了 部署博客还是和以前一样： 1. hexo g -d 如果提示 RROR Deployer not found: git 说明前面 npm install --save hexo-deployer-git 没有执行成功 再执行一次 2. npm install --save hexo-deployer-git 博客已经成功部署到master分支，这时候到github查看两个分支的内容，hexo分支里是源文件，master里是静态文件 注意：根目录下的_config.yml配置文件中branch一定要填master，否则hexo d就会部署到hexo分支下。 关联到远程hexo分支如果有修改的话 ,在本地新建一个hexo分支别忘了，要推送到hexo分支上去： git add . git commit -m &quot;&quot; git push origin hexo 这样才能在另外的机器上pull下来，保持同步 MAC机器个人PC上的工作已经完成了，下面讲一下如果你换到了另外一台电脑上，应该如何操作。 将博客项目克隆下来git clone xxx 克隆下来的仓库可能是master分支（我已经设置hexo为默认分支了 但是clone下来还是master分支）这时候需要切换一下分支，所以可以在这基础上继续写博客了。 #查看所有分支 git branch -a #切换分支 git checkout hexo 但是由于.gitignore文件中过滤了node_modules\，所以克隆下来的目录里没有node_modules\，这是hexo所需要的组件，所以要在该目录中重新安装hexo，但不需要hexo init。 npm install hexo npm install npm install hexo-deployer-git --save 新建一篇文章测试hexo g -d 推送到hexo分支git add . git commit -m &quot;add work PC test&quot; git push origin hexo 部署到master分支hexo g -d 日常操作如果上面的过程都操作无误的话，你就可以在任何能联网的电脑上写博客啦。一般写博客的流程是下面这样。 写博客前不管你本地的仓库是否是最新的，都先pull一下，以防万一： git pull origin hexo 把最新的pull下来，再开始撰写新的博客。 写博客hexo new “title”然后打开source/_posts/title.md，撰写博文。 写完博客先推送到hexo分支上： git add . git commit -m &quot;add article xxx&quot; git push origin hexo 最后部署到master分支上hexo g -d 整个流程大概就是这样。 再次回到Windows机器等我再次回到Windows机器上的时候,我git pull下最新的代码,但是提示我如下错误 $ hexo g ERROR Local hexo not found in E:\Hexo ERROR Try running: &apos;npm install hexo --save&apos; 这个时候你需要:1.删除node_modules文件夹2.执行一下代码 npm install 然后在执行 hexo g -d 3.原因 .gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

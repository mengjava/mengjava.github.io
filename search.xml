<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是编译，什么是反编译。Java的编译和反编译方法。]]></title>
    <url>%2F2019%2F02%2F11%2Fz002%2F</url>
    <content type="text"><![CDATA[在介绍编译和反编译之前，我们先来简单介绍下编程语言（Programming Language）。编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。 而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。 上面提到语言有两种，一种低级语言，一种高级语言。可以这样简单的理解：低级语言是计算机认识的语言、高级语言是程序员认识的语言。 那么如何从高级语言转换成低级语言呢？这个过程其实就是编译。将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。 反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将class文件转换成java文件。 Java语言中负责编译的编译器是一个命令：javac javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。 当我们写完一个HelloWorld.java文件后，我们可以使用javac HelloWorld.java命令来生成HelloWorld.class文件，这个class类型的文件是JVM可以识别的文件。通常我们认为这个过程叫做Java语言的编译。其实，class文件仍然不是机器能够识别的语言，因为机器只能识别机器语言，还需要JVM再将这种class文件类型字节码转换成机器可以识别的机器语言。]]></content>
      <categories>
        <category>直面Java</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java是一种面向对象的语言。]]></title>
    <url>%2F2019%2F02%2F11%2Fz001%2F</url>
    <content type="text"><![CDATA[思考题：什么是面向对象，什么是面向过程。面向对象的三大基本特征和五大基本原则是什么？什么是面向过程？把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。 什么是面向对象？将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。 面向对象的三大基本特征和五大基本原则？三大基本特征：封装、继承、多态。五大基本原则：单一职责原则（Single-Responsibility Principle）、开放封闭原则（Open-Closed principle）、Liskov替换原则（Liskov-Substituion Principle）、依赖倒置原则（Dependency-Inversion Principle）和 接口隔离原则（Interface-Segregation Principle）。 后话：这些东西虽然都是概念性的，但是很多程序员根本不知道，更别提如何更好的面向对象编程了，我就看过有些同学写的代码，从头到尾一个函数，各种if-else，完全不考虑复用、扩展等。这种代码非常不利于阅读和维护。希望不仅记住上面的概念，还要通汇贯通，切实的运用到平时的工作中。]]></content>
      <categories>
        <category>直面Java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring单例模式与线程安全]]></title>
    <url>%2F2019%2F01%2F28%2FSpring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[一、Spring单例模式与线程安全Spring框架里的bean，或者说组件，获取实例的时候都是默认的单例模式，这是在多线程开发的时候要尤其注意的地方。 单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单列状态的修改（体现为该单列的成员属性），则必须考虑线程同步问题 同步机制的比较ThreadLocal和线程同步机制相比有什么优势呢？ ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。 概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 Spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程 ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。 1） 常量始终是线程安全的，因为只存在读操作。2）每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。3）局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。 有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。 有状态对象:无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。Struts2默认的实现是Prototype模式。也就是每个请求都新生成一个Action实例，所以不存在线程安全问题。需要注意的是，如果由Spring管理action的生命周期， scope要配成prototype作用域。 Prototype原型模式Spring中依赖注入的默认对象为单例形式，@Scope(“prototype”)注解可以将其改变为原型模式。 改变底层（如service层）的对象为原型时，同时改变上层调用层（如controller层）的调用方式，原型模式才会生效。 https://blog.csdn.net/unifirst/article/details/50482031#commentshttps://www.cnblogs.com/ViviChan/p/4981619.html]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>线程安全</tag>
        <tag>Prototype作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql性能优化]]></title>
    <url>%2F2019%2F01%2F28%2Fmysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.一般应急调优的思路：123456789101112131、show processlistSHOW PROCESSLIST显示哪些线程正在运行show processlist 详细介绍2、查看执行计划 查看索引3、通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题4、show status like &apos;%lock%&apos;; # 查询锁状态 kill SESSION_ID; # 杀掉有问题的session 2.常规调优思路：针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。1234567891、查看slowlog，分析slowlog，分析出查询慢的语句。慢查询具体操作2、按照一定优先级，进行一个一个的排查所有慢语句。3、分析top sql，进行explain调试，查看语句执行时间。4、调整索引或语句本身。 3.什么情况下不走索引123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因 2. 字符串与数字比较不使用索引; CREATE TABLE `a` (`a` char(10)); EXPLAIN SELECT * FROM `a` WHERE `a`=&quot;1&quot; -- 走索引 EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引 select * from dept where dname=&apos;xxx&apos; or loc=&apos;xx&apos; or deptno=45 --如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or 关键字 3. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引4.前导模糊查询不能使用索引如:select name from user where name like &apos;%zhangsan&apos;非前导则可以:select name from user where name like &apos;zhangsan%&apos;建议可以考虑使用 Lucene 等全文索引工具来代替频繁的模糊查询。5.负向查询不能使用索引select name from user where id not in (1,3,4);应该修改为:select name from user where id in (2,5,6);6.在字段上进行计算不能命中索引select name from user where FROM_UNIXTIME(create_time) &lt; CURDATE();应该修改为:select name from user where create_time &lt; FROM_UNIXTIME(CURDATE());7.最左前缀问题如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:select username from user where username=&apos;zhangsan&apos; and pwd =&apos;axsedf1sd&apos;select username from user where pwd =&apos;axsedf1sd&apos; and username=&apos;zhangsan&apos;select username from user where username=&apos;zhangsan&apos;但是使用select username from user where pwd =&apos;axsedf1sd&apos;是不能命中索引的。8. 如果明确知道只有一条记录返回select name from user where username=&apos;zhangsan&apos; limit 1可以提高效率，可以让数据库停止游标移动。9.不要让数据库帮我们做强制类型转换select name from user where telno=18722222222这样虽然可以查出数据，但是会导致全表扫描。需要修改为select name from user where telno=&apos;18722222222&apos;10.如果需要进行 join 的字段两表的字段类型要相同不然也不会命中索引。 4.索引选择原则123456781. 较频繁的作为查询条件的字段应该创建索引2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件3. 更新非常频繁的字段不适合创建索引4. 不会出现在 WHERE 子句中的字段不该创建索引5. 数据区分不明显的不建议创建索引如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。字段的默认值不要为 null这样会带来和预期不一致的查询结果。]]></content>
      <categories>
        <category>mysql性能优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Face++行驶证OCR识别]]></title>
    <url>%2F2018%2F12%2F24%2Fface%2F</url>
    <content type="text"><![CDATA[官方API地址为: https://console.faceplusplus.com.cn/documents/5671706首先创建自己的账号 生成api_key api_secret 具体代码如下123456789101112131415161718public String ocrVehicleLicenseOrMergeFace(@RequestParam(&quot;imageUrl&quot;) String imageUrl,@RequestParam(&quot;group&quot;) String group,@RequestParam(&quot;type&quot;) Integer type) throws IOException &#123; String image_url=FILE_INNER_URL+group+&quot;/&quot;+imageUrl; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost uploadFile = new HttpPost(LICENSE_URL); MultipartEntityBuilder builder = MultipartEntityBuilder.create(); builder.addTextBody(&quot;api_key&quot;, API_KEY, ContentType.TEXT_PLAIN); builder.addTextBody(&quot;api_secret&quot;, API_SECRET, ContentType.TEXT_PLAIN); builder.addTextBody(&quot;image_url&quot;, image_url, ContentType.TEXT_PLAIN); // 把文件加到HTTP的post请求中 HttpEntity multipart = builder.build(); uploadFile.setEntity(multipart); CloseableHttpResponse response = httpClient.execute(uploadFile); HttpEntity responseEntity = response.getEntity(); //转换值 String sResponse = EntityUtils.toString(responseEntity, &quot;UTF-8&quot;); LicenseResult licenseResult = JSONObject.parseObject(sResponse, LicenseResult.class); return JSONUtil.toJsonStringSUSSESS(&quot;查询成功&quot;, licenseResult); &#125;]]></content>
      <categories>
        <category>Face++</category>
      </categories>
      <tags>
        <tag>行驶证OCR识别</tag>
        <tag>Face++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公平锁与非公平锁]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%2F</url>
    <content type="text"><![CDATA[在ReentrantLock中很明显可以看到其中同步包括两种，分别是公平的FairSync 和非公平的 NonfairSync。公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 默认情况下ReentrantLock是通过非公平锁来进行同步的，包括synchronized关键字都是如此，因为这样性能会更好。因为从线程进入了Runnable状态，可以执行开始，到实际线程执行是要比较久的时间的。而且，在一个锁释放之后，其他的线程会需要重新来获取锁。其中经历了持有锁的线程释放锁，其他线程从挂起恢复到Runnable状态，其他线程请求锁，获得锁，线程执行，这一系列步骤。如果这个时候，存在一个线程直接请求锁，可能就避开挂起到恢复Runnable状态的这段消耗，所以性能更优化。1234567/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125; 默认状态，使用的ReentrantLock()就是非公平锁。再参考如下代码，我们知道ReentrantLock的获取锁的操作是通过装饰模式代理给sync的。 1234567891011121314151617/** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */public void lock() &#123; sync.lock();&#125; 下面参考一下FairSync和NonfairSync对lock方法的实现： 12345678910111213141516171819202122232425/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125;&#125;/** * Sync object for fair locks */static final class FairSync extends Sync &#123; final void lock() &#123; acquire(1); &#125;&#125; 当使用非公平锁的时候，会立刻尝试配置状态，成功了就会插队执行，失败了就会和公平锁的机制一样，调用acquire()方法，以排他的方式来获取锁，成功了立刻返回，否则将线程加入队列，知道成功调用为止。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>公平锁</tag>
        <tag>非公平锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Mac和Windows上同时写Hexo博客？]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%A6%82%E4%BD%95%E5%9C%A8mac%E5%92%8CWindows%E4%B8%8A%E5%90%8C%E6%97%B6%E5%86%99hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先，我是在公司上的windows机器上部署了hexo，但是回家后发现很不方便，家里的电脑是mac机。所以根据网上的经验我总结了一下如何在mac和Windows上同时写hexo博客。 Windows机器这是我在公司的机器，本来以为不同系统会很麻烦，弄完发现一点也不麻烦。 在github上新建远程仓库将原来的page项目删除，新建一个和原来名字一样的空项目。不用初始化README.md 此时只有一个空的master分支。 本地初始化一个Hexo项目注意：本地的目录不要动 重新新建一个空目录，作为你的博客目录。进入该目录，右击Git bash here，初始化一个Hexo项目：123hexo initnpm installnpm install hexo-deployer-git --save 然后用自己原来博客里的文件替换掉这里的source\, scaffolds\, themes\,_config.yml替换成自己原来博客里的。 注意，这里把themes/next中的.git/目录删除 将整个目录推送到master要推送到master分支，首先要将该目录初始化为本地Git仓库： 123456git init//把博客目录下所有文件推送到master分支git remote add origin xxgit add .git commit -m &quot;first add hexo source code&quot;git push origin master 注意：如果不小心初始化了README.md 在执行 git push origin master 会失败.。此时先执行以下命令进行代码合并 1git push origin master 在github上新建一个分支1.创建本地分支 git branch 分支名，例如：git branch hexo 2.切换本地分支 git checkout 分支名，例如从master切换到分支：git checkout hexo 3.远程分支就是本地分支push到服务器上。比如master就是一个最典型的远程分支（默认）。 git push origin hexo 4.设置默认分支 git branch --set-upstream-to=origin/hexo hexo 新建一个分支hexo(名字可以自定义)，这时候hexo分支和master分支的内容一样，都是hexo的源文件。并把hexo设为默认分支，这样的话在另外一台机器上克隆下来就直接进入hexo分支，并且以后所有操作都是在hexo分支下完成。 为什么需要这个额外的分支呢？ 因为hexo d只把静态网页文件部署到master分支上，所以你换了另外一台电脑，就无法pull下来继续写博客了。有了hexo分支的话，就可以把hexo分支中的源文件(配置文件、主题样式等)pull下来，再hexo g的话就可以生成一模一样的静态文件了 部署博客还是和以前一样： 1. hexo g -d 如果提示 RROR Deployer not found: git 说明前面 npm install --save hexo-deployer-git 没有执行成功 再执行一次 2. npm install --save hexo-deployer-git 博客已经成功部署到master分支，这时候到github查看两个分支的内容，hexo分支里是源文件，master里是静态文件 注意：根目录下的_config.yml配置文件中branch一定要填master，否则hexo d就会部署到hexo分支下。 关联到远程hexo分支如果有修改的话 ,在本地新建一个hexo分支别忘了，要推送到hexo分支上去： git add . git commit -m &quot;&quot; git push origin hexo 这样才能在另外的机器上pull下来，保持同步 MAC机器个人PC上的工作已经完成了，下面讲一下如果你换到了另外一台电脑上，应该如何操作。 将博客项目克隆下来git clone xxx 克隆下来的仓库可能是master分支（我已经设置hexo为默认分支了 但是clone下来还是master分支）这时候需要切换一下分支，所以可以在这基础上继续写博客了。 #查看所有分支 git branch -a #切换分支 git checkout hexo 但是由于.gitignore文件中过滤了node_modules\，所以克隆下来的目录里没有node_modules\，这是hexo所需要的组件，所以要在该目录中重新安装hexo，但不需要hexo init。 npm install hexo npm install npm install hexo-deployer-git --save 新建一篇文章测试hexo g -d 推送到hexo分支git add . git commit -m &quot;add work PC test&quot; git push origin hexo 部署到master分支hexo g -d 日常操作如果上面的过程都操作无误的话，你就可以在任何能联网的电脑上写博客啦。一般写博客的流程是下面这样。 写博客前不管你本地的仓库是否是最新的，都先pull一下，以防万一： git pull origin hexo 把最新的pull下来，再开始撰写新的博客。 写博客hexo new “title”然后打开source/_posts/title.md，撰写博文。 写完博客先推送到hexo分支上： git add . git commit -m &quot;add article xxx&quot; git push origin hexo 最后部署到master分支上hexo g -d 整个流程大概就是这样。 再次回到Windows机器等我再次回到Windows机器上的时候,我git pull下最新的代码,但是提示我如下错误 $ hexo g ERROR Local hexo not found in E:\Hexo ERROR Try running: &apos;npm install hexo --save&apos; 这个时候你需要:1.删除node_modules文件夹2.执行一下代码 npm install 然后在执行 hexo g -d 3.原因 .gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

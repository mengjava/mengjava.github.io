<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第2章 装配bean]]></title>
    <url>%2F2019%2F05%2F22%2F%E7%AC%AC2%E7%AB%A0-%E8%A3%85%E9%85%8Dbean%2F</url>
    <content type="text"><![CDATA[2.1 Spring配置的可选方案创建应用对象之间协作关系的行为通常称为装配，这也是依赖注入(DI)的本质。Spring提供了三种主要的装配机制： 在XML中进行显示装配。 在Java中进行显示装配。 隐式的bean发现机制和自动装配。 2.2 自动化装配beanSpring从两个角度来实现自动化装配： 组件扫描：Spring会自动发现应用上下文中所创建的bean。 自动装配：Spring自动满足bean之间的依赖。 2.2.1 创建可被发现的bean@Component注解表示类会作为组件类，并告知Spring要为这个类创建bean。不过组件扫描默认不是开启的。我们还需要显示配置一下Spring，从而命令它寻找带有@Component注解的类，并为其创建bean。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。 如果你更倾向于使用XML来启用组件扫描的话，那么可以使用Spring context命名空间的context:component-scan元素。 2.2.2 为组件扫描的bean命名Spring应用上下文中所有的bean都会给定一个ID。默认情况下会根据类名为其指定一个ID。类名的第一个字母变为小写。如果想设置不同的ID，有两种方式： 1 只需要在@Component(“名字”)即可。 2 使用Java依赖注入规范中所提供的@Named注解来为bean设置IDSpring支持将@Named作为@Component注解的代替方案。 2.2.3 设置组件扫描的基础包可以在@ComponentScan的value属性中指明包的名称 @ComponentScan(“soudssystem”),如果你想更清晰的设置，可以通过basePackages属性进行配置@ComponentScan(basePackages=”soundssystem”) basePackages是复数形式因此也可以设置多个@ComponentScan(basePackages={“soundssystem”,”video”)上面这种形式是使用String类型进行设置的，如果代码重构，所指定的基础包可能就会出现错误。 除了将包设置为简单的String类型之外，@ComponentScan()还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：@ComponentScan(basePackageClasses={类名.class,接口名.class}) 2.2.4自动装配如果所有对象相互独立，彼此没有任何依赖，只需要组件扫描。但是很多对象会依赖其他的对象才能完成任务。这样的话我们就需要一种方法能够将组件扫描得到的bean和它们的依赖装配在一起。要完成这项任务，就需要了解一下Spring的自动装配。 简单的说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，要借助Spring的@Autowired注解。@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。 如果没有找到匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常，你可以将@Autowired的requried属性设置为false。如果匹配到了多个bean，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。如果不喜欢用@Autowired，可以用@Inject代替，@Inject注解来源于Java依赖注入规范，该规范同时提供了@Named注解。 2.3 通过Java代码装配bean如果你想把第三方库中的组件装配到你的应用中，没办法在它的类上使用@Component和@Autowired注解，因此就不能使用Java配置。 如果进行显示装配有两种方案：Java配置和XML配置。 在进行显示配置的时候，JavaConfig是更好的方案，同时JavaConfig和Java代码又有所区别，JavaConfig是配置代码，通常要将JavaConfig放到单独的包中，使它与其他应用逻辑分离开来，这样对于它的意图就不会产生困惑了。 2.3.1 创建配置创建配置类的关键在于为其添加@Configuration注解，此注解表明这个类是一个注解类，该类应该包含在Spring应用上下文中如何创建bean的细节。 2.3.2 声明简单的bean 要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解。 @Bean注解会告诉Spring这个方法会返回一个对象，该对象要注入为Spring应用上下文中的bean。 默认情况下bean的ID与带有@Bean注解的方法名是一样的。 2.3.3 借助JavaConfig实现注入在JavaConfig中装配bean的最简单的方式就是引用创建bean的方法。默认情况下，Spring中的bean是单例的，Spring会拦截对相同方法对调用并确保返回的是Spring所创建的bean。也可以作为参数进行传递，Spring会把参数自动装配成bean，也可以通过Setter方法进行注入。 2.4 通过XML装配bean2.4.1 创建XML配置规范首先创建一个XML文件，并且要以元素为根。用来装配bean最基本的XML元素包含在spring-beans模式之中。 2.4.2 声明一个简单的要在基于XML的Spring配置中声明一个bean，我们要使用spring-beans模式中的另一个元素：。元素类似于JavaConfig中的@Bean注解。 1&lt;bean class="soudsystem.SgtPeppers"&gt; 这里声明了一个简单的bean，创建这个bean的类通过class属性指定的，并且要使用全限定名。因为没有明确给定ID，所以这个bean将会根据全限定名进行命名。bean的ID将会是soudsystem.SgtPeppers#0 ，#0是用来区别相同类型的其他bean。 通常最好的办法就是定义id属性，为每个bean设置一个你自己的名字：1&lt;bean id=“compactDIsc” class="soudsystem.SgtPeppers"&gt; 为了减少XML中繁琐的配置，只对那些需要按名字引用的bean进行明确地命名 2.4.3 借助构造器注入初始化bean在SpringXML配置中，只有一种声明bean的方式：使用元素并指定class属性。Spring会从这里获取必要的信息来创建bean。 在XML中声明DI时，有两种基本的配置方案： 元素 使用Spring3.0所引用的c-命名空间 1 构造器注入bean引用 2 将字面量注入到构造器中 我们所做的DI通话指的都是类型装配–也就是将对象的引用装配到依赖于它们的其他对象之中。 在装配方面，比c-命名空间更有优势。目前使用c-命名空间无法实现装配集合的功能。 使用和c-命名空间实现构造器注入时，它们之间还有一些细微的差别。 2.4.4 设置属性 可以通过构造器或者setter进行注入。 将字面量注入到属性中：我们需要装配这些属性，可以借助元素的value属性实现该功能。 2.5 导入和混合配置2.5.1 在JavaConfig中引用XML配置@Import(类名.class) 这个注解会引入这个类中的所有bean。可以使用@Import将两个javaConfig的配置组合在一起。 123456789@Configuration@Import(CDconfig.class)public class CDPlayerConfig&#123;@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; return new CDPyayer(compactDisc) &#125;&#125; 或者12345@Configuration@Import(CDconfig.class,CDPlayerConfig)public class CDPlayerConfig&#123;&#125; 如果使用XML配置，可以使用@ImportResoure注解12345@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath:cd-config.xml")public class SoundSystemConfig&#123;&#125; 2.5.2 在XML配置中引用JavaConfig在JavaConfig配置中，我们已经展现了如何使用@Import和@ImportResource来拆分JavaConfig类。在XML中，我们可以元素来拆分XML配置。 基于XML的配置该如何引用一个JavaConfig类呢? 可以使用 或者将CDConfig bean从之前的XML文件中移除,使用第三个配置文件将这两个组合在一起。两个文件一个用XML描述，另一个使用Java描述。]]></content>
      <categories>
        <category>Spring实战读书笔记</category>
      </categories>
      <tags>
        <tag>装配bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义并发框架]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[需求的产生和分析 公司里有两个项目组，考试组有批量的离线文档要生成，题库组则经常有批量的题目进行排重和根据条件批量修改题目的内容。 架构组通过对实际的上线产品进行用户调查，发现这些功能在实际使用时，用户都反应速度很慢，而且提交任务后，不知道任务的进行情况，做没做？做到哪一步了？有哪些成功？哪些失败了？都一概不知道。 架构组和实际的开发人员沟通，他们都说，因为前端提交任务到Web后台以后，是一次要处理多个文档和题目，所以速度快不起来。提示用多线程进行改进，实际的开发人员表示多线程没有用过，不知道如何使用，也担心用不好。综合以上情况，架构组决定在公司的基础构件库中提供一个并发任务执行框架，以解决上述用户和业务开发人员的痛点：1、对批量型任务提供统一的开发接口2、在使用上尽可能的对业务开发人员友好3、要求可以查询批量任务的执行进度 需要做什么要实现这么一个批量任务并发执行的框架，我们来分析一下我们要做些什么？1、批量任务，为提高性能，必然的我们要使用java里的多线程，为了在使用上尽可能的对业务开发人员友好和简单，需要屏蔽一些底层java并发编程中的细节，让他们不需要去了解并发容器，阻塞队列，异步任务，线程安全等等方面的知识，只要专心于自己的业务处理即可。2、每个批量任务拥有自己的上下文环境，因为一个项目组里同时要处理的批量任务可能有多个，比如考试组，可能就会有不同的学校的批量的离线文档生成，而题库组则会不同的学科都会有老师同时进行工作，因此需要一个并发安全的容器保存每个任务的属性信息，3、自动清除已完成和过期任务因为要提供进度查询，系统需要在内存中维护每个任务的进度信息以供查询，但是这种查询又是有时间限制的，一个任务完成一段时间后，就不再提供进度查询了，则就需要我们自动清除已完成和过期任务，用定时轮询吗？用延迟队列 具体实现可查询进度的并发任务执行框架1、用户业务方法的结果？一个方法执行的结果有几种可能？三种，成功：按预想的流程出了结果；失败：按按预想的流程没出结果；异常：没按预想的流程抛出了预料之外的错误。因此我们定义了一个枚举，表示这三种情况， 12345678/** *类说明：方法本身运行是否正确的结果类型 */public enum TaskResultType &#123; Success,/*方法执行完成，业务结果也正确*/ Failure,/*方法执行完成，业务结果错误*/ Exception/*方法执行抛出了异常*/&#125; 对于方法的业务执行结果，返回值有很多种可能，基本类型，系统定义的对象类型，用户自定义的对象类型都是存在的，我们需要用泛型来说表示这个结果。同时方法执行失败了，我们还需要告诉用户或者业务开发人员，失败的原因，我们再定义了一个任务的结果类。 1234567public class TaskResult&lt;R&gt; &#123; private final TaskResultType resultType;/*方法执行结果*/ private final R returnValue;/*方法执行后的结果数据*/ private final String reason;/*如果方法失败，这里可以填充原因*/ 2、如何执行用户的业务方法？ 我们是个框架，用户的业务各种各样，都要放到我们框架里执行，怎么办？当然是定义个接口，我们的框架就只执行这个方法，而使用我们框架的业务方都应该来实现这个接口，当然因为用户业务的数据多样性，意味着我们这个方法的参数也应该用泛型。12345678/** * *类说明：要求框架使用者实现的任务接口，因为任务的性质在调用时才知道， *所以传入的参数和方法的返回值均使用泛型 */public interface ITaskProcesser&lt;T, R&gt; &#123; TaskResult&lt;R&gt; taskExecute(T data);&#125; 3、用户如何提交他的工作和查询任务进度？ 用户在前端提交了工作（JOB）到后台，我们需要提供一种封装机制，让业务开发人员可以将任务的相关信息提交给这个封装机制，用户的需要查询进度的时候，也从这个封装机制中取得，同时我们的封装机制内部也要负责清除已完成任务。在这个封装机制里我们定义了一个类JobInfo，抽象了对用户工作的封装，一个工作可以包含多个子任务（TASK），这个JobInfo中就包括了这个工作的相关信息，比如工作名，用以区分框架中唯一的工作，也可以避免重复提交，也方便查询时快速定位工作，除了工作名以外，工作中任务的列表，工作中任务的处理器都在其中定义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** *类说明：提交给框架执行的工作实体类, * 工作：表示本批次需要处理的同性质任务(Task)的一个集合 */public class JobInfo&lt;R&gt; &#123; private final String jobName;/*工作名，用以区分框架中唯一的工作*/ private final int jobLength;/*工作中任务的长度*/ private final ITaskProcesser&lt;?, ?&gt; taskProcesser;/*处理工作中任务的处理器*/ private AtomicInteger successCount;/*任务的成功次数*/ private AtomicInteger taskProcessCount;/*工作中任务目前已经处理的次数*/ /*存放每个任务的处理结果，供查询用*/ private LinkedBlockingDeque&lt;TaskResult&lt;R&gt;&gt; taskDetailQueues; private final long expireTime;/*保留的工作的结果信息供查询的时长*/ private static CheckJobProcesser checkJob = CheckJobProcesser.getInstance(); public JobInfo(String jobName,int jobLength, ITaskProcesser&lt;?, ?&gt; taskProcesser, long expireTime) &#123; this.jobName = jobName; this.jobLength = jobLength; successCount = new AtomicInteger(0); taskProcessCount = new AtomicInteger(0); this.taskProcesser = taskProcesser; taskDetailQueues = new LinkedBlockingDeque&lt;TaskResult&lt;R&gt;&gt;(jobLength); this.expireTime = expireTime; &#125; public int getSuccCount() &#123; return successCount.get(); &#125; public int getTaskProcessCount() &#123; return taskProcessCount.get(); &#125; //提供工作中失败的次数 public int getFailCount() &#123; return taskProcessCount.get() - successCount.get(); &#125; public ITaskProcesser&lt;?, ?&gt; getTaskProcesser() &#123; return taskProcesser; &#125; public int getJobLength() &#123; return jobLength; &#125; /*提供工作的整体进度信息*/ public String getTotalProcess() &#123; return "Success["+successCount.get()+"]/Current["+taskProcessCount.get() +"] Total["+jobLength+"]"; &#125; /*提供工作中每个任务的处理结果*/ public List&lt;TaskResult&lt;R&gt;&gt; getTaskDetail()&#123; List&lt;TaskResult&lt;R&gt;&gt; taskResultList = new LinkedList&lt;&gt;(); TaskResult&lt;R&gt; taskResult; while((taskResult=taskDetailQueues.pollFirst())!=null)&#123; taskResultList.add(taskResult); &#125; return taskResultList; &#125; /*每个任务处理完成后，记录任务的处理结果，因为从业务应用的角度来说， 对查询任务进度数据的一致性要不高 我们保证最终一致性即可，无需对整个方法加锁*/ public void addTaskResult(TaskResult&lt;R&gt; taskResult)&#123; if(TaskResultType.Success.equals(taskResult.getResultType()))&#123; successCount.incrementAndGet(); &#125; taskProcessCount.incrementAndGet(); taskDetailQueues.addLast(taskResult); if(taskProcessCount.get()==jobLength)&#123; checkJob.putJob(jobName,expireTime); &#125; &#125;&#125; 负责清除已完成任务，我们则交给CheckJobProcesser类来完成，定时轮询的机制不够优雅，因此我们选用了DelayQueue来实现这个功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** *类说明：任务完成后,在一定的时间供查询结果， * 之后为释放资源节约内存，需要定期处理过期的任务 */public class CheckJobProcesser &#123; /*存放任务的队列*/ private static DelayQueue&lt;ItemVo&lt;String&gt;&gt; queue = new DelayQueue&lt;ItemVo&lt;String&gt;&gt;(); /*单例化*/ private static class ProcesserHolder&#123; public static CheckJobProcesser processer = new CheckJobProcesser(); &#125; public static CheckJobProcesser getInstance() &#123; return ProcesserHolder.processer; &#125; /*处理队列中到期任务*/ private static class FetchJob implements Runnable&#123; private static DelayQueue&lt;ItemVo&lt;String&gt;&gt; queue = CheckJobProcesser.queue; //缓存的工作信息 private static Map&lt;String,JobInfo&lt;?&gt;&gt; jobInfoMap = PendingJobPool.getMap(); @Override public void run() &#123; while(true)&#123; try&#123; ItemVo&lt;String&gt; item = queue.take(); String jobName = (String)item.getData(); jobInfoMap.remove(jobName); System.out.println(jobName+" 过期了，从缓存中清除"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /*任务完成后，放入队列，经过expireTime时间后，会从整个框架中移除*/ public void putJob(String jobName,long expireTime)&#123; ItemVo&lt;String&gt; item = new ItemVo&lt;&gt;(expireTime,jobName); queue.offer(item); System.out.println(jobName+"已经放入过期检查缓存，时长："+expireTime); &#125; static&#123; Thread thread = new Thread(new FetchJob()); thread.setDaemon(true); thread.start(); System.out.println("开启过期检查的守护线程......"); &#125; &#125; 4、框架的主体类主体类则是PendingJobPool，这也是业务开发人员主要使用的类。这个类主要负责调度，例如工作（JOB）和任务（TASK）的提交，任务（TASK）的保存，任务（TASK）的并发执行，工作进度的查询接口和任务执行情况的查询等等。]]></content>
      <categories>
        <category>课堂整理笔记</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发安全]]></title>
    <url>%2F2019%2F05%2F19%2F%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[什么是并发安全当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称为这个类时是线程安全的。 线程封闭避免并发最简单的方法就是线程封闭。就是把对象封装到线程里，只有这个线程能看到此对象。那么这个对象就算不是线程安全的也不会出现任何安全问题。 实现线程封闭的方法： ad-hoc 线程封闭：这个完全靠实现者控制的线程封闭，他的线程封闭完全靠实现者实现。栈封闭 栈封闭：简单来说栈封闭就是局部变量。多个线程访问一个方法，此方法中的局部变量都会被拷贝一份到线程栈中。所以局部变量不是被多个线程所共享的，也就不会出现并发问题。 无状态的类没有任何成员变量的类就是无状态类，这个种类一定是线程安全的。 让类不可变让类不可变有两种方式： 1 加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的泪也要是不可变，才能够保证整个类是不可变的。 2 根本就不提供任何可供修改的成员变量的地方，同时成员变量也不作为方法的返回值。 加锁和CAS最常见的线程安全的手段，使用synchronized关键字，使用显示锁，使用各种原子变量，修改数据时使用CAS机制等等。 安全的发布类中持有的成员变量，如果基本类型发布出去，并没有关系，因为发布出去的是一个变量的副本。但是类中持有的成员变量是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从个人造成整个线程类线程不安全的问题。 TheadLocalTheadLocal是实现线程封闭最好方法。ThreadLocal内部维护一个Map，Map的key是每个线程的名称，而Map的值就是我们要封闭的对象。每个线程中对象都对应着Map中一个值，也就是ThreadLocal利用Map实现了对象的线程封闭。 Servlet辨析Servlet不是线程安全的类：1 在需求上，很少有共享的需求2 接收到了请求，返回应答的时候，一般都是由一个线程来负责的。但是只要Servlet中有成员变量，一旦有多个线程的写，就很容易产生线程安全问题。 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 学术化的定义死锁的发生必须具备以下四个必要条件： 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，•••，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源 现象、危害和解决在我们IT世界有没有存在死锁的情况，有：数据库里多事务而且要同时操作多个表的情况下。所以数据库设计的时候就考虑到了检测死锁和从死锁中恢复的机制。比如oracle提供了检测和处理死锁的语句，而mysql也提供了“循环依赖检测的机制” 现象：简单顺序死锁：一眼就能看出来动态顺序死锁：动态的顺序可能导致的死锁。 危害：1.线程不工作。2.没有任何的异常信息可以提供我们检查。3.一旦程序发生了死锁，是没有任何的办法恢复的，只能重启程序，对生产平台的程序来说，这个是很严重的问题；测试也不好发现。 解决 定位通过jps查询应用的id，再通过jstack id查看应用的锁的持有情况 修正关键是保证那锁的顺序一致性两种解决方法：a 内部通过顺序比较，确定拿锁的顺序；b 采用尝试拿锁的机制。 其他安全问题活锁两个线程尝试拿锁的机制中，发生了多个线程相互谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。解决办法：每个线程休眠随机数，错开拿锁的时间。 线程饥饿低优先级的线程，总是拿不到执行时间 并发下的性能使用并发的目标是为了提高性能，引入多线程后，其实会引入额外的开销，如线程之间的协调、增加的上下文切换，线程的创建和销毁，线程的调度等等。过度的使用和不恰当的使用，会导致多线程程序甚至比单线程还要低。 衡量应用的程序的性能：服务时间，延迟时间，吞吐量，可伸缩性等等，其中服务时间，延迟时间（多快），吞吐量（处理能力的指标，完成工作的多少）。多快和多少，完全独立，甚至是相互矛盾的。 线程引入的开销1 上下文切换2 内存同步同步操作的性能开销包括多个方面。在 synchronized和 volatile提供的可见性保证中可能会使用一些特殊指令,即内存栅栏( Memory Barrier)。内存栅栏可以刷新缓存,使缓存无效刷新硬件的写缓冲,以及停止执行管道。内存栅栏可能同样会对性能带来间接的影响,因为它 3 阻塞引起阻塞的原因：包括阻塞IO,等待获取发生竞争的锁,或者在条件变量上等待等等。 如何减少锁的竞争1 减少锁的粒度使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁 2 缩小锁的范围对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作 3 避免多余的锁两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化—扩大锁的范围。 4 锁分段ConcurrrentHashMap就是典型的锁分段。 5 替换独占锁在业务允许的情况下：1、 使用读写锁，2、 用自旋CAS3、使用系统的并发容器]]></content>
      <categories>
        <category>课堂整理笔记</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 Spring之旅]]></title>
    <url>%2F2019%2F05%2F12%2F%E7%AC%AC1%E7%AB%A0%20Spring%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[1.1 简化Java开发相对于EJB来说，Spring提供了更加轻量级和简单的编程模型。它增强了简单老式Java对象的功能，使其具备了之前只有EJB和其他企业级Java规范才具有的功能。 为了降低Java开发的复杂性，Spring采取了以下4种关键策略。 基于POJO的轻量级和最小入侵性编程； 通过依赖注入和面向接口编程实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模版减少样板式代码； 1.1.1 激发POJO的潜能Spring竭力避免因自身的API而弄乱你的应用代码。Spring不会强迫你实现Spring规范的接口或继承Spring规范类，相反，在基于Spring构建的应用中，它的类通常没有任何痕迹表明你使用了Spring。 1.1.2 依赖注入DI功能是如何实现的任何一个有实际意义的应用都会由两个或更多的类组成，这些类之间相互进行协作来完成特定的业务逻辑。按照传统的做法，每个对象负责管理与自己相互协作的对象的引用，这将会导致高度耦合和难以测试的代码。 通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设置。对象无需自行创建或管理他们的依赖关系，依赖关系将被自动注入到需要他们的对象中。 Spring有多种装bean的方式，采用XML是很常见的一种装配方式，Spring还支持使用Java来描述配置。 Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。 1.1.3 应用切面DI能够让相互协作的组件保持松散耦合，而面向切面编程（aspect-oriented-programiming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。 AOP能够使这些服务模块化，并以声明的方法将他们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更关注自身的业务，完全不需要了解涉及系统服务所带来的复杂性。总之，AOP能够确保POJO的简单性。 1.1.4 使用模版消除样式代码Spring旨在通过模板封装来消除样板式代码。Spring的JdbcTemplate使得执行数据库操作时，避免传统的JDBC样板代码成为可能。 1.2 容纳你的bean容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。Spring的容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。 bean工厂（由org.springframework.beans.factroy.BeanFactory接口定义）是简单的容器，提供基本的DI支持。应用上下文（由org.springframwork.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。 bean工厂对大多数应用来说往往太低级了，因此，应用上下文要比bean工厂更受欢迎。 1.2.1 使用应用上下文Spring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的 AnnotationConfigAppliationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。 AnnotationConfigWwbbApplicationContext:从一个或多个基于Java的配置中加载Spring Web应用上下文。 ClassPathXmlApplicationCOntext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。 FileSystemXmlApplicationCOntext；从文件系统下的一个或多个XML配置文件中加载上下文定义。 XmlWebApplicationContext：从Web应用下的一个或多个XMl配置文件中加载上下文定义。 应用上下文准备就绪之后，我们就可以调用上下文的getBean（）方法从Spring容器中获取bean。 1.2.2 bean的声明周期在传统的Java应用中，bean的声明周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。 Spring容器中的bean声明周期就显得相对复杂多了。下图展示了bean装载到Spring应用上下文的一个典型的生命周期过程。 1 Spring对bean进行实例化； 2 Spring将值和bean的引用注入到bean对应的属性中； 3 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法； 4 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactroy容器实例传入。 5 如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext（）方法，将bean所在的应用上下文的引用传入进来。 6 如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法。 7 如果bean实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该发放也会被调用。 8 如果bean实现了BeanPostProcessor接口，Spring将调用他们的postProcesAfterInitialization()方法； 9 此时，bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，知道该应用上下文被销毁； 10 如果bean实现了DisPosableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用了destroy-method声明了销毁方法，该方法也会被调用。 1.3 俯览Spring风景线1.3.1 Spring模块Spring核心容器容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Spring bean工厂，它为Spring 提供了DI的功能。基于bean工厂，我们还会发现多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail，JNDI访问，EJB集成和调度。 Spring的AOP模块在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统开发切面的基础。与DI一样，AOP可以忙著应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事物和安全）从它们所应用的对象中解耦出来。 数据访问集成使用JDBC编写代码通常会导致大量的样板式代码、例如获取数据连接、创建语句、处理结果集到最后关闭数据库连接。模块包括ORM、JMS、Spring应用中的对象提供事务管理服务。 Web与远程调用MVC模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离。Java从来不缺少MVC框架，APache的Struts、JSF‘WebWork和Tapestry都可是可选的最流行的MVC框架。该模块还提供了多种构建与其他应用交互的远程调用方案。 instrumentation此模块提供了为JVM添加代理的功能。具体来讲，它为Tomacat提供了一个织入代理，能够为Tomacat传递类文件，就像这些文件是被类加载器加载一样。 测试通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载SPring上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。 1.3.2 Spring Portfolio整个Spring Portfolio包括多个构建于核心Spring框架之上的框架和类库。 Spring Web Flow建立于SpringMVC框架之上，它为基于流程的会话式Web应用提供支持。 Spring Web Service提供了契约优先的WebService模型，服务的实现都是为了满足服务的契约而编写的。 Spring Security为Spring应用提供了声明式的安全机制。 Spring Integration提供了多种通用应用集成模式的Spring声明式风格实现。 Spring Batch通过Spring Batch，使用Spring强大的面向POJO的编程模型。 Spring Data它使得在Spring使用任何数据库都变得非常容易。 Spring SocialSpring的一个社交网络扩展模块。 Spring Mobile它是Spring MVC新的扩展模块，用于支持移动web应用开发。 Spring for Android通过Spring框架为开发基于Android设备的本地应用提供某些简单的支持。 Spring BootSpring Boot 大量依赖于自动配置技术，它能够消除大部分Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都会减少Spring工程构建文件的大小。 1.4 Spring的新功能1.4.1 Spring3.1新特性其中很多都是关于如何简化和改善配置的。除此之外，Spring3.1还提供了声明式缓存的支持以及众多针对SpringMVC的功能增强。 1.4.2 Spring3.2新特性Spring3.1在很大程度上聚焦于配置改善以及其他的一些增强，包括SPringMVC的增强，而Spring3.2是主要关注SpringMVC的一个发布版本。]]></content>
      <categories>
        <category>Spring实战读书笔记</category>
      </categories>
      <tags>
        <tag>javabean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1案例分析]]></title>
    <url>%2F2019%2F04%2F01%2F5-1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1 高性能硬件上的程序部署策略在高性能硬件上部署程序，目前主要有两种方式： 通过64位JDK来使用大内存 使用这种方法要考虑一下问题: 内存收回导致的长时间停顿 现阶段,64位JDK的性能测试普遍低于32位JDK. 需要保证程序足够稳定,因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产十几个GB仍至更大的Dump文件),即使生成了快照也几乎无法分析。 相同程序在64位JDK消耗的内存一般比32位JDK大,这是由于指针膨胀,以及数据类型对齐补白等因素导致的。 使用若干个32位虚拟机加你了逻辑集群来利用硬件资源具体做法是在一台物理机上启动多个应用服务器进程,每个服务器进程分配不同端口,然后在前端搭建一个负载均衡器,以反向代理的方式来分配访问请求。使用逻辑集群部署程序会遇到一下问题： 尽量避免节点竞争全局资源，例如各个节点同时访问某个磁盘文件，很容易导致IO异常。 很难最高效的利用某些资源池，譬如连接池。 各个节点仍然不可避免地受到32位的内存限制（32位Windows平台每个进程只能使用2GB的内存）。 大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用。 2 集群间同步导致的内存溢出使用全局缓存，服务多次出现内存溢出问题 首先让服务带着 -XX：+HeapDumpOnOutOfMemoryError参数运行一段时间，查看heapdump文件，发现有大量的org.jgroups.protocols.pbcast.NAKACK对象。发现是信息传输失败需要重发，重发数据在内存中不断堆积，很快产生了内存异常。这个缺陷是由于JBossCacache的缺陷导致的。 3 堆外内存导致的溢出错误 4 外部命令导致系统缓慢每个用户请求的处理都需要执行一个外部shell脚本来获取系统的一些信息。执行shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的,这种方式调用会克隆一个和当前虚拟机拥有一样环境变量的进程,如果频繁执行这个操作,系统的消耗很大,内存负担很重。 5 服务器JVM进程崩溃 6 由Windows虚拟机内存导致的长时间停顿长时间停顿首先加入参数-XX:+PrintGCApplicationStoppedTIme -XX:+printGCDateStamps -Xloggc:gclog.log后,从GC日志中确认停顿确实有GC导致的，偶尔会出现接近一分钟的GC。 主要原因是GUI程序内存变化的一个特点，当它最小化的时候，资源管理器显示的占用内存大幅度减小，但是虚拟机内存没有变化，因此怀疑程序在最小化时他的工作内容被自动交换到自盘的页面文件之中了，这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿。解决办法就是加入-Dsun.awt.keepWorkingSetOnMinimize=tru参数来解决。这个参数保证程序在恢复最小化时能够立即响应。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>案例分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3 JDK的可视化工具]]></title>
    <url>%2F2019%2F04%2F01%2F4-3-JDK%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[JConsole:Java监视与管理控制台JConsole(Java monitoring and Management Console)是一种基于JMX的可视化监视管理工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码，中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。 1. 启动JConsole:通过JDK/bin目录下的”jconsole.exe” 启动JConsole后,将自动搜多出所有虚拟机进程 2.内存监控:用于监视收集器管理的虚拟机内存（Java堆和永久代）的变化趋势（相当于jstat）。JConsole监视的代码，如下： 通过JConsole监视，在“内存”页签中可以看到内存池Eden区的运行趋势呈现折线状。而监视范围扩大至整个堆后，会发现曲线是一条向上增长的平滑曲线。并且从柱状图可以看出，在1000次循环执行结束，运行了System.gc()后，虽然整个新生代Eden和Survivor区都基本清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在System.gc()方法执行之后仍然存活。 问题：为何执行了System.gc()之后，老年代的柱状图仍然显示峰值状态，代码需要如何调整才能让System.gc()回收掉填充到堆中的对象？ 答案：执行System.gc()时，空间未能回收是因为List list对象仍然存活，fillHeap()方法仍然没有退出，因此list对象在System.gc()执行时仍然处于作用域中。如果把System.gc()移动到fillHeap()方法外调用就可以回收掉全部内存。 注意：准确的说，只有在虚拟机使用解释器执行的时候，“在作用域之内”才能保证它不会被回收，因为这里的回收还涉及局部变量表Slot复用，即时编译介入时机等问题。 3 线程监控 :用于线程停顿时可以使用此进行监控（相当于jstack),遇到线程停顿时可以使用这个页签进行监控分析。线程长时间停顿的主要原因有： 等待外部资源(数据库连接、网络资源、设备资源等) 死循环 锁等待（活锁和死锁） VisualVM：多合一故障处理工具Visual VM（All-in One Java Troubleshooting Tool) 是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。 功能： 包括：运行监视，故障处理，性能分析等。而且Visual VM的还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。 1.VisualVM 兼容范围与插件安装VisualVM基于NetBeans平台，因此她具备了插件扩展功能的特性，通过插件扩展支持，VisualVM可以做到： 1 虚拟机进程已经进程的配置、环境信息（jps、jinfo) 2 监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack） 3 dump以及分析堆转储快照（jmap、jstack）。 4 方法级的程序运行新更能分析，找出被调用最多、运行时间最长的方法。 5 离线程序快照:手机程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者进行Bug反馈。 6 其他plugins的无限可能性 2.生成、浏览堆转储快照3.分析程序性能 要开始分析,选择CPU和内存按钮中的一个,然后切换到应用程序中堆程序进行操作,VisualVM会记录到这段时间中应用程序执行过的方法。会将统计每个方法的执行次数、执行消耗； 4 BTrace动态日志跟踪 BTrace是一个VisualVM插件，作用是在不停止目标程序运行的前提下,通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码,通过调试增量来加入日志代码以解决问题。BTrace打印调用堆栈、参数、返回值只是最基础的应用，在它的网站上有使用BTrace进行性能监视、定位链接侧漏和内存侧漏、解决多线程竞争问题等例子。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>可视化工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1 JDK的命令行工具]]></title>
    <url>%2F2019%2F04%2F01%2F4-1-JDK%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[jps:虚拟机进程状态工具 jps(JVM Process Status Tool) 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程本地虚拟机唯一ID。 jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态,hostid为RMI注册表中注册的主机名。 命令1：jps -l：输出主类的全名，如果进程执行的是Jar包，输出Jar路径： 命令2：jps -v：输出虚拟机进程启动时JVM参数： 命令3：jps -m：输出虚拟机进程启动时传递给主类main()函数的参数： 命令4：jps -q：只输出LVMID，省略主类的名称： jstat: 虚拟机统计信息监视工具 jstat(JVM Statistics Monitoring Tool) 是用于监视虚拟机各种运行状态的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT便建议等运行数据，他是运行期定位虚拟机性能问题的首选工具。 使用jstat工具在纯文本状态下监视虚拟机不如VisualVm等可视化工具直接一图表展示的那么直观。 命令1：jstat -gc 13991 200 5：每200毫秒查询一次进程2764垃圾收集状况，一共查询5次 命令2：jstat -gcutil 13991 200 5：监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比： jinfo:Java配置信息工具jinfo(Configuration Info for Java) 的作用是实时地查看和调整虚拟机各项参数。使用jps命令订单-v参数可以查看虚拟机启动时显式制定的参数列表，但是如果想知道未被显式指定的参数的系统默认值，除了找资料外，就只能使用jinfo的-flag选项进行查询了，还可以使用-sysprops选项吧虚拟机进程的System.getProperties()的内容打印出来。 命令1：jinfo -flag CMSInitiatingOccupancyFraction 13991：查询CMSInitiatingOccupancyFraction参数值。 jmap:Java内存映像工具jmap(Memory Map for Java) 命令用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如通过-XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件；通过-XX:+HeapDumpOnCtrlBreak参数则可以使用[Ctrl] + [Break]键让虚拟机生成dump文件；或者在Linux系统下通过kill -3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。 作用: 1 生成堆转储快照 2 查询finalize执行队列、Java堆和永久代的信息，如空间使用率，当前使用的收集器。 命令1：jmap -dump:format=b,file=idea.bin 7996 jhat：虚拟机堆转储快照分析工具Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。不过实事求是地说，在实际工作中，很少使用jhat命令来分析dump文件，主要原因有二： （1）一般不会在部署应用程序的服务器上直接分析dump文件，即时可以这样做，也会尽量将dump文件复制到其他机器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程；（2）jhat命令分析功能相对来说比较简陋。 命令1：jhat idea.bin 在浏览器输入 http://localhost:7000/ jstack:Java堆栈跟踪工具jstack（Stack Trace for Java) 令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合. 生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。 命令1 jstack -l 7996 JDK1.5中,java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机所有线程的StackTraceElement对象。通过这个方法可以简单代码完成jstack的大部分功能，可以做个管理界面用于查看线程堆栈。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>命令行工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.4 内存分配和回收策略]]></title>
    <url>%2F2019%2F04%2F01%2F3-4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[1 对象优先在eden分配大部分情况下,兑现在新生代Eden区分配.当Eden区域没有足够空间进行分配，虚拟机发起一次Minor GC。 新生代GC（Minor GC）:指发生在新生代的垃圾收集动作,Moinor GC发生非常频繁,一般回收速度比较快。 老年代GC（Major GC/Full GC):指在老年代发生的GC。 2 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串数组。虚拟机提供了一个-XX：pretenureSizeThreshold参数，大于这个设置的值直接进入老年代。这也做避免Eden区及Survivor区之间发生大量的内存复制。 3 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活,并能被Survivor容纳的话,将被移动Survivor空间，年龄设置为1。每发生一次Minor GC 年龄增加一岁。当年龄增加到15岁（默认值）将会晋升到老年代。年龄参数可以通过-XX:MaxTenuringThreshold设置。 ４动态对象年龄判断虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold,如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一般,那么年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到MaxTenuringThreshold中要求的年龄。 5 空间分配担保在发生Minor GC之前,会先检查老年代最大的连续空间是否大于新生代所有对象空间总和,如果条件成立,那么MinorGc才是安全的。如果不成立，则虚拟机查看HandlePromotionFailure设置是否允许担保失败。如果允许，那么查看老年代最大可用连续空间是否大于历次晋升到老年代的平均值，若果大于则则尝试进行一次MinorGC（这次MinorGC是有风险的）。如果设置成不允许冒险,则进行一次Full GC。JDK6之后不在使用HandlePromotionFailure参数，只要老年代连续空间大于新生代空间的总和或历次晋升的平均大小就进行Minor GC，否则进行Full GC。 冒险的含义： 新生代使用复制收集算法,但是为了内存利用率,只是用Survior空间来轮换备份,因此当出现大量的对象在Minor GC后仍然存活(极端情况下为内存回收后新生代中所有对象都存活)，此时就需要老年代来担保，把Survior无法容纳的对象直接放入老年代。前提是来年代本身有容纳那些对象的剩余空间。因此取之前每一次回收晋升到老年代对象容量的平均值作为经验值，与老年代剩余空间做比价，决定是否需要进行Full GC来让老年代腾出更多的空间。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>内存分配和回收策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3 垃圾收集器]]></title>
    <url>%2F2019%2F04%2F01%2F3-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Serial 收集器（新生代）这是一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，进行垃圾收集时，必须暂停其他所有的工作线程。实际使用场景：依然是虚拟机运行在Client模式下的默认新生代收集器。例如 用户桌面应用场景中，分配给虚拟机管理的内存不会很大，停顿时间在几十毫秒最多一百多毫秒以内，这点停顿是可以接受的。优点：简单高效，对于限定CPU的环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集。 ParNew 收集器（新生代）ParNew收集器是Serial收集器的多线程版本,除了使用多线程进行垃圾收集之外,其余行为包括Serial收集器可用的所有控制参数、收集算法、对象分配规则、回收策略等都和Serial收集器完全一样。实际使用场景：Server模式下的虚拟机中首选的新生代收集器。因为除了Serial收集器外，目前只有它可以与CMS收集器配合工作。Parallel Scavenge收集器无法和CMS配合工作。 -XX:+UseConcMarkSweepGc :ParNew收集器也是使用此配置的默认新生代收集器 -XX:+UserParNewGC: 此配置强制使用ParNew收集器为新生代收集器 -XX:ParallelGCThreads:参数来限制垃圾收集器的线程数。 Parallel Scavenge 收集器(新生代)使用复制算法并且多线程的收集器，和ParNew类似。特点：Parallel Scavenge收集器的目标是达到一个可控的吞吐量。吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)自适应调节策略:-XX:+UseAdaptivePolicy 这个参数打开后,不需要手工指定对象年龄等参数细节,动态调整这些参数提供最合适的停顿时间和最大吞吐量。 Serial Old收集器（老年代）单线程收集器 使用标记标记-整理算法，主要用于Client模式下的虚拟机使用。 Parallel Old 收集器（老年代）多线程使用“标记-整理”短发。JDK1.6中才开始提供。配合Parallel Scavenge使用。 CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现。一共分为四个步骤 初始标记 并发标记 重新标记（为了修正并发标记期间因用户程序继续运行而导致而导致标记产生变动的那一部分对象的标记记录） 并发清除 缺点： CMS收集器对CPU资源非常敏感。CMS默认启动的回收线程数是（CPU数量+3）/4,当CPU在4个以上时,并发回收时垃圾手机线程不少于25%的CPU资源,但是当小于4时,CMS对用户的影响就变得更大,影响用户使用。 CMS无法处理浮动垃圾可能会出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。浮动垃圾就是并发清除的时候产生的垃圾。 基于“标记-清除”算法那实现的收集器，结束后会产生大量空间碎片。碎片过多会导致即使老年代即使还有很大空间剩余，但是找不到连续的空间，还是会触发Full GC。为了解决这个问题CMS提供了-XX:+UseCMSCompactAtFullConllection开关参数,用于在FullGC时开启内存碎片的合并整理。 G1收集器是当今收集器技术发展的最前沿成果之一，G1收集器把整个Java堆划分为多个大小相等的独立区域（Region）,新生代和老年代不再是隔离的。 特点: 并行和并发: G1充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短停顿时间。 分代收集:G1可以不需要其他收集器配合就可以独立管理整个GC堆。 空间整合：基于标记整理算法，从局部上（两个Region之间）是基于复制算法，两种算法都意味着G1运作期间不会产生内存空间碎片。 可预测的停顿：G1追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确之情在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N秒。可预测停顿原因：G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个有限列表，每一个根据时间，优先回收价值最大的Region。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2 垃圾回收算]]></title>
    <url>%2F2019%2F04%2F01%2F3-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1 标记-清除算法（老年代）标记：标记出所有需要回收的对象，在标记完成后同意回收所有被标记的对象。清除：回收对象不足： a 标记和清除两个过程的效率都不高； b 标记清除之后产生大量的不连续内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收。 2 复制算法（新生代） 为了解决效率问题 内存按照容量划分为大小相等的两块，每次使用其中的一块。一块用完了 就将还存活的对象移动到另一端，然后再把已经使用过的内存空间一次清理掉。 优点:每次都对半个区域进行内存回收,无需考虑内存碎片等复杂情况。 不按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收的时候把Eden和survivor上存活的对象一次性复制到另一块Survior上。最后清理掉Survivor和Eden空间。Eden和Survivor的大小比例为8:1:1 这样之后10%空间被浪费掉,没办法保证每次只回收不多于10%的对象存活,当Survivor空间不足时,需要依赖其他内存(老年代),进行分配担保。 老年代不要使用复制算法 原因：复制算法在对象存活率较高的时候就要进行较多的复制操作，效率会变低，如果不是按照1:1的比例,就需要额外的空间担保,应对对象100存活的极端情况。 3 标记整理（老年代） 和标记-清除一样，后续步骤不是直接对可回收对象进行清除，而是让存活对象移动到另一端，进行整理，另一端的内存进行清除。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>垃圾回收算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1 对象已死了吗]]></title>
    <url>%2F2019%2F04%2F01%2F3-1-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E4%BA%86%E5%90%97%2F</url>
    <content type="text"><![CDATA[1 引用计数法给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效的时候计数器减一；缺点： 很难解决对象相互循环引用的问题。 2.可达性分析算法通过一系列的称为“GC Roots”的对象作为起始点，从这个节点开始往下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots对象没有任何引用链相连时，则证明此对象是不可用的，所以他们将会被判定为可回收对象。 在Java语言中，可作为GC Roots的对象包括下面几种： a 虚拟机栈（战阵中的本地变量表）中引用的对象。 b 方法区中静态属性引用对象。 c 方法去中常量引用的对象。 d 本地方法栈中JNI（一般说的是Native）引用的对象。 引用JDK1.2之后 Java分为4种 强引用 软引用 若引用 虚引用 拯救对象一个对象死亡最少要经历两次标记过程第一次：发现与GC Roots没有引用链，进行标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。对象没有覆盖finalize（）方法或finalize()方法已经执行过了,视为没必要执行。第二次：被判定为必须执行finalize()方法的对象,将此对象放入到一个F-Queue的队列之中,稍后GC将对这个队列里的对象进行二次标记.如果对象在finalize()中成功拯救自己,只要重新与引用链上的任何对象建立关联即可。此时它将会呗移出“即将回收”的集合。finalize()方法只会被执行一次。 回收方法区方法区的垃圾收集主要回收两部门内容 废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。 废弃常量：没有任何对象引用即为废弃常量。无用类： a 该类所有实例都已经被回收。 b 加载该类的ClassLoader已经被回收。 c 该类对应的java.lang.Class 对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>对象存活分析算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-4虚拟机OOM异常情况]]></title>
    <url>%2F2019%2F03%2F31%2F2-4%E8%99%9A%E6%8B%9F%E6%9C%BAOOM%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[1 Java堆溢出首先分析清除到底是出现了内存泄露还是内存溢出 如果是内存泄露,可进一步通过工具查看泄露对象到GC Roots的引用链.找到泄露对象和GC Roots的关联,是怎么导致泄露对象无法自动回收的.通过泄露对象的类型信息和GC Roots引用链的信息.准确定位到泄露代码的位置。如果不存在泄露，检查虚拟机参数（-Xmx和-Xms），与机器物理内存对比看是否还可以调大。 2 虚拟机栈和本地方法栈溢出栈容量只由-Xss参数设置。两种异常： a 线程请求的栈深度大于虚拟机允许的最大深度，将抛出SOE异常。在单线程程序的操作中，无论栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候都会抛出SOE异常 b 虚拟机在扩展的时候无法申请到足够的内存空间，则会抛出OOM异常（解决方法 减小栈帧的内存）。在多线程的情况下，不断创建线程可以产生OOM，-Xss的参数越大，创建的线程数量自然就越少，创建线程的时候越容易把内存耗尽。 3 方法区和运行时常量池溢出使用String。intern（）无限添加字符串到常量池中。String.intern()作用:如果字符串常量池已经包含了一个等于此String对象的字符串,最返回代表池中这个字符串的String 对象.否则将此String对象包含的字符串添加到常量池中,并返回代表池中这个字符串的STring对象。 JDK1.6和JDK1.7 string.intern()的区别 JDK1.6中,intern()方法会把首次遇到的字符串实例复制到永久代中,返回永久代中这个字符串实例的引用;JDK1.7中,intern()实现不会复制实例,只是在常量池中记录首次出现的实例引用,因此intern()返回堆中这个字符串实例引用. 4 本机直接内存溢出directMemory(直接内存)容量可以通过-XX: MaxDirectMemorySize指定,如果不指定,默认和Java堆最大值(-Xmx)一样。]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>Java内存溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3 hotspot的算法实现]]></title>
    <url>%2F2019%2F03%2F31%2F2-3-hotspot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[枚举根节点GC的时候所有Java执行线程必须停顿。原因：可达性分析工作必须在一个能保证一致性(系统看起来像冻结在了某个节点)的快照中进行,GC的时候是通过可达性分析进行回收对象的,所以要停顿所有Java线程。 OopMap数据结构：可达性分析从GC Root是 节点找引用链的时候，需要逐个检查这些引用，会消耗很多时间。有了OopMap数据额结构，系统停顿下来后，并不需要一个不漏的检查所有的引用链节点，类加载完成时，HotSpot就把对象内的信息记录到OopMap数据结构中。 安全点HotSpot没有为每一条指令都生成OopMap，只有到了特定的位置才会记录这些信息，这个位置称为安全点。 为了让所有线程在发生GC的时候都跑到安全点上再停下来（为了生成OopMap），有两种方案 方案A：抢先式中断 不需要线程的执行代码主动去配合，在GC发生时,所有线程全部中断,如果有线程中断的地方没有安全点,那么就恢复线程让他执行到安全点上，目前没有虚拟机采用这种方式 方案B：主动式中断不直接对线程操作，而是设置一个表示，各个线程执行时去主动轮训这个标志，发现中断标志为真时就把自己中断挂起，轮训标志和安全点是重合的，再加上创建对象需要分配内存的地方 安全区域程序执行的时候才会进入安全点，中断请求，如果程序不执行（线程处于Sleep或者Blocaked状态），无法相应JVM的中断请求。此时需要安全区域来解决。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在此区域任何地方开始GC都是安全的。可以看成是被扩展的安全点]]></content>
      <categories>
        <category>JVM读书笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Java的语法糖，列举你个知道的语法糖。如何解语法糖？]]></title>
    <url>%2F2019%2F02%2F11%2Fz003%2F</url>
    <content type="text"><![CDATA[语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。 解语法糖 前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。 说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。 Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理，一步一步剥去糖衣，看看其本质。 糖块一、 switch 支持 String 与枚举前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中switch开始支持String。 在开始coding之前先科普下，Java中的swith自身原本就支持基本类型。比如int、char等。对于int类型，直接进行数值的比较。对于char类型则是比较其ascii码。所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte、short、char（ackii码是整型）以及int。 那么接下来看下switch对String得支持，有以下代码： public class switchDemoString { public static void main(String[] args) { String str = “world”; switch (str) { case “hello”: System.out.println(“hello”); break; default: break; } }}反编译后内容如下： public class switchDemoString{ public switchDemoString() { } public static void main(String args[]) { String str = “world”; String s; switch((s = str).hashCode()) { default: break; case 99162322: if(s.equals(“hello”)) System.out.println(“hello”); break; } }}看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。还好hashCode()方法返回的是int，而不是long。 仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。 糖块二、 泛型我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。 Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。 也就是说，对于Java虚拟机来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。 类型擦除的主要过程如下： 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。移除所有的类型参数。以下代码： Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(“name”, “hollis”);解语法糖之后会变成： Map map = new HashMap();map.put(“name”, “hollis”); 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List.class或是List.class，而只有List.class。 糖块三、 自动装箱与拆箱自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。 先来看个自动装箱的代码： public static void main(String[] args) { int i = 10; Integer n = i;}反编译后代码如下: public static void main(String args[]){ int i = 10; Integer n = Integer.valueOf(i);} 从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 所以，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。 糖块四 、 方法变长参数可变参数(variable arguments)是在Java 1.5中引入的一个特性，它允许一个方法把任意数量的值作为参数。 看下以下可变参数代码，其中print方法接收可变参数： public static void main(String[] args) { print(“Holis”, “公众号:Hollis”, “博客：www.hollischuang.com&quot;); } public static void print(String… strs){ for (int i = 0; i &lt; strs.length; i++) { System.out.println(strs[i]); }}反编译后代码： public static void main(String args[]){ print(new String[] { “Holis”, “\u516C\u4F17\u53F7:Hollis”, “\u535A\u5BA2\uFF1Awww.hollischuang.com&quot; });} public static transient void print(String strs[]){ for(int i = 0; i &lt; strs.length; i++) System.out.println(strs[i]); }从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。 糖块五 、 枚举Java SE5提供了一种新的类型-Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。 要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举： public enum t { SPRING,SUMMER;}然后我们使用反编译，看看这段代码到底是怎么实现。 通过反编译后代码我们可以看到（内容太多不贴了，读者自行反编译了解下），public final class T extends Enum，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。 糖块六 、 内部类内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。 内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，分别是outer.class和outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。 糖块七 、条件编译—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。 如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码： public class ConditionalCompilation { public static void main(String[] args) { final boolean DEBUG = true; if(DEBUG) { System.out.println(“Hello, DEBUG!”); } final boolean ONLINE = false; if(ONLINE){ System.out.println(“Hello, ONLINE!”); } }}反编译后代码如下： public class ConditionalCompilation{ public static void main(String args[]) { boolean DEBUG = true; System.out.println(“Hello, DEBUG!”); boolean ONLINE = false; }}首先，我们发现，在反编译后的代码中没有System.out.println(“Hello, ONLINE!”);，这其实就是条件编译。当if(ONLINE)为false的时候，编译器就没有对其内的代码进行编译。 所以，Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译，这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。 糖块八 、 断言在Java中，assert关键字是从 Java SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关-enableassertions或-ea来开启。 看一段包含断言的代码： public class AssertTest { public static void main(String args[]) { int a = 1; int b = 1; assert a == b; System.out.println(“公众号：Hollis”); assert a != b : “Hollis”; System.out.println(“博客：www.hollischuang.com&quot;); }}反编译后代码太多，不贴了，但是很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。-enableassertions会设置$assertionsDisabled字段的值。 糖块九 、 数值字面量在Java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。 比如： public class Test { public static void main(String… args) { int i = 10_000; System.out.println(i); }}反编译后： public class Test{ public static void main(String[] args) { int i = 10000; System.out.println(i); }}反编译后就是把删除了。也就是说 编译器并不认识在数字字面量中的，需要在编译阶段把他去掉。 糖块十 、 for-each增强for循环（for-each）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？ public static void main(String… args) { String[] strs = {“Hollis”, “公众号：Hollis”, “博客：www.hollischuang.com&quot;}; for (String s : strs) { System.out.println(s); }}反编译后代码如下： public static transient void main(String args[]){ String strs[] = { “Hollis”, “\u516C\u4F17\u53F7\uFF1AHollis”, “\u535A\u5BA2\uFF1Awww.hollischuang.com&quot; }; String args1[] = strs; int i = args1.length; for(int j = 0; j &lt; i; j++) { String s = args1[j]; System.out.println(s); }}代码很简单，for-each的实现原理其实就是使用了普通的for循环和迭代器。 糖块十一 、 try-with-resourceJava里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。 关闭资源的常用方式就是在finally块里是释放，即调用close方法。比如，我们经常会写这样的代码：1234567891011121314151617181920public static void main(String[] args) &#123; BufferedReader br = null; try &#123; String line; br = new BufferedReader(new FileReader(&quot;d:\\hollischuang.xml&quot;)); while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // handle exception &#125; finally &#123; try &#123; if (br != null) &#123; br.close(); &#125; &#125; catch (IOException ex) &#123; // handle exception &#125; &#125;&#125; 从Java 7开始，jdk提供了一种更好的方式关闭资源，使用try-with-resources语句，改写一下上面的代码，效果如下：12345678910public static void main(String... args) &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;))) &#123; String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // handle exception &#125;&#125; 看，这简直是一大福音啊，虽然我之前一般使用IOUtils去关闭流，并不会使用在finally中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后： public static transient void main(String args[]) { BufferedReader br; Throwable throwable; br = new BufferedReader(new FileReader(“d:\ hollischuang.xml”)); throwable = null; String line; try { while((line = br.readLine()) != null) System.out.println(line); } catch(Throwable throwable2) { throwable = throwable2; throw throwable2; } if(br != null) if(throwable != null) try { br.close(); } catch(Throwable throwable1) { throwable.addSuppressed(throwable1); } else br.close(); break MISSING_BLOCK_LABEL_113; Exception exception; exception; if(br != null) if(throwable != null) try { br.close(); } catch(Throwable throwable3) { throwable.addSuppressed(throwable3); } else br.close(); throw exception; IOException ioexception; ioexception; }}其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。 总结前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。 有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。]]></content>
      <categories>
        <category>直面Java</category>
      </categories>
      <tags>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是编译，什么是反编译。Java的编译和反编译方法。]]></title>
    <url>%2F2019%2F02%2F11%2Fz002%2F</url>
    <content type="text"><![CDATA[在介绍编译和反编译之前，我们先来简单介绍下编程语言（Programming Language）。编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。 而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。 上面提到语言有两种，一种低级语言，一种高级语言。可以这样简单的理解：低级语言是计算机认识的语言、高级语言是程序员认识的语言。 那么如何从高级语言转换成低级语言呢？这个过程其实就是编译。将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。 反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将class文件转换成java文件。 Java语言中负责编译的编译器是一个命令：javac javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。 当我们写完一个HelloWorld.java文件后，我们可以使用javac HelloWorld.java命令来生成HelloWorld.class文件，这个class类型的文件是JVM可以识别的文件。通常我们认为这个过程叫做Java语言的编译。其实，class文件仍然不是机器能够识别的语言，因为机器只能识别机器语言，还需要JVM再将这种class文件类型字节码转换成机器可以识别的机器语言。]]></content>
      <categories>
        <category>直面Java</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java是一种面向对象的语言。]]></title>
    <url>%2F2019%2F02%2F11%2Fz001%2F</url>
    <content type="text"><![CDATA[思考题：什么是面向对象，什么是面向过程。面向对象的三大基本特征和五大基本原则是什么？什么是面向过程？把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。 什么是面向对象？将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。 面向对象的三大基本特征和五大基本原则？三大基本特征：封装、继承、多态。五大基本原则：单一职责原则（Single-Responsibility Principle）、开放封闭原则（Open-Closed principle）、Liskov替换原则（Liskov-Substituion Principle）、依赖倒置原则（Dependency-Inversion Principle）和 接口隔离原则（Interface-Segregation Principle）。 后话：这些东西虽然都是概念性的，但是很多程序员根本不知道，更别提如何更好的面向对象编程了，我就看过有些同学写的代码，从头到尾一个函数，各种if-else，完全不考虑复用、扩展等。这种代码非常不利于阅读和维护。希望不仅记住上面的概念，还要通汇贯通，切实的运用到平时的工作中。]]></content>
      <categories>
        <category>直面Java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring单例模式与线程安全]]></title>
    <url>%2F2019%2F01%2F28%2FSpring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[一、Spring单例模式与线程安全Spring框架里的bean，或者说组件，获取实例的时候都是默认的单例模式，这是在多线程开发的时候要尤其注意的地方。 单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单列状态的修改（体现为该单列的成员属性），则必须考虑线程同步问题 同步机制的比较ThreadLocal和线程同步机制相比有什么优势呢？ ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。 概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 Spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程 ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。 1） 常量始终是线程安全的，因为只存在读操作。2）每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。3）局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。 有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。 有状态对象:无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。Struts2默认的实现是Prototype模式。也就是每个请求都新生成一个Action实例，所以不存在线程安全问题。需要注意的是，如果由Spring管理action的生命周期， scope要配成prototype作用域。 Prototype原型模式Spring中依赖注入的默认对象为单例形式，@Scope(“prototype”)注解可以将其改变为原型模式。 改变底层（如service层）的对象为原型时，同时改变上层调用层（如controller层）的调用方式，原型模式才会生效。 https://blog.csdn.net/unifirst/article/details/50482031#commentshttps://www.cnblogs.com/ViviChan/p/4981619.html]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>线程安全</tag>
        <tag>Prototype作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql性能优化]]></title>
    <url>%2F2019%2F01%2F28%2Fmysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.一般应急调优的思路：123456789101112131、show processlistSHOW PROCESSLIST显示哪些线程正在运行show processlist 详细介绍2、查看执行计划 查看索引3、通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题4、show status like &apos;%lock%&apos;; # 查询锁状态 kill SESSION_ID; # 杀掉有问题的session 2.常规调优思路：针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。1234567891、查看slowlog，分析slowlog，分析出查询慢的语句。慢查询具体操作2、按照一定优先级，进行一个一个的排查所有慢语句。3、分析top sql，进行explain调试，查看语句执行时间。4、调整索引或语句本身。 3.什么情况下不走索引123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因 2. 字符串与数字比较不使用索引; CREATE TABLE `a` (`a` char(10)); EXPLAIN SELECT * FROM `a` WHERE `a`=&quot;1&quot; -- 走索引 EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引 select * from dept where dname=&apos;xxx&apos; or loc=&apos;xx&apos; or deptno=45 --如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or 关键字 3. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引4.前导模糊查询不能使用索引如:select name from user where name like &apos;%zhangsan&apos;非前导则可以:select name from user where name like &apos;zhangsan%&apos;建议可以考虑使用 Lucene 等全文索引工具来代替频繁的模糊查询。5.负向查询不能使用索引select name from user where id not in (1,3,4);应该修改为:select name from user where id in (2,5,6);6.在字段上进行计算不能命中索引select name from user where FROM_UNIXTIME(create_time) &lt; CURDATE();应该修改为:select name from user where create_time &lt; FROM_UNIXTIME(CURDATE());7.最左前缀问题如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:select username from user where username=&apos;zhangsan&apos; and pwd =&apos;axsedf1sd&apos;select username from user where pwd =&apos;axsedf1sd&apos; and username=&apos;zhangsan&apos;select username from user where username=&apos;zhangsan&apos;但是使用select username from user where pwd =&apos;axsedf1sd&apos;是不能命中索引的。8. 如果明确知道只有一条记录返回select name from user where username=&apos;zhangsan&apos; limit 1可以提高效率，可以让数据库停止游标移动。9.不要让数据库帮我们做强制类型转换select name from user where telno=18722222222这样虽然可以查出数据，但是会导致全表扫描。需要修改为select name from user where telno=&apos;18722222222&apos;10.如果需要进行 join 的字段两表的字段类型要相同不然也不会命中索引。 4.索引选择原则123456781. 较频繁的作为查询条件的字段应该创建索引2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件3. 更新非常频繁的字段不适合创建索引4. 不会出现在 WHERE 子句中的字段不该创建索引5. 数据区分不明显的不建议创建索引如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。字段的默认值不要为 null这样会带来和预期不一致的查询结果。]]></content>
      <categories>
        <category>mysql性能优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Face++行驶证OCR识别]]></title>
    <url>%2F2018%2F12%2F24%2Fface%2F</url>
    <content type="text"><![CDATA[官方API地址为: https://console.faceplusplus.com.cn/documents/5671706首先创建自己的账号 生成api_key api_secret 具体代码如下123456789101112131415161718public String ocrVehicleLicenseOrMergeFace(@RequestParam(&quot;imageUrl&quot;) String imageUrl,@RequestParam(&quot;group&quot;) String group,@RequestParam(&quot;type&quot;) Integer type) throws IOException &#123; String image_url=FILE_INNER_URL+group+&quot;/&quot;+imageUrl; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost uploadFile = new HttpPost(LICENSE_URL); MultipartEntityBuilder builder = MultipartEntityBuilder.create(); builder.addTextBody(&quot;api_key&quot;, API_KEY, ContentType.TEXT_PLAIN); builder.addTextBody(&quot;api_secret&quot;, API_SECRET, ContentType.TEXT_PLAIN); builder.addTextBody(&quot;image_url&quot;, image_url, ContentType.TEXT_PLAIN); // 把文件加到HTTP的post请求中 HttpEntity multipart = builder.build(); uploadFile.setEntity(multipart); CloseableHttpResponse response = httpClient.execute(uploadFile); HttpEntity responseEntity = response.getEntity(); //转换值 String sResponse = EntityUtils.toString(responseEntity, &quot;UTF-8&quot;); LicenseResult licenseResult = JSONObject.parseObject(sResponse, LicenseResult.class); return JSONUtil.toJsonStringSUSSESS(&quot;查询成功&quot;, licenseResult); &#125;]]></content>
      <categories>
        <category>Face++</category>
      </categories>
      <tags>
        <tag>行驶证OCR识别</tag>
        <tag>Face++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公平锁与非公平锁]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%2F</url>
    <content type="text"><![CDATA[在ReentrantLock中很明显可以看到其中同步包括两种，分别是公平的FairSync 和非公平的 NonfairSync。公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 默认情况下ReentrantLock是通过非公平锁来进行同步的，包括synchronized关键字都是如此，因为这样性能会更好。因为从线程进入了Runnable状态，可以执行开始，到实际线程执行是要比较久的时间的。而且，在一个锁释放之后，其他的线程会需要重新来获取锁。其中经历了持有锁的线程释放锁，其他线程从挂起恢复到Runnable状态，其他线程请求锁，获得锁，线程执行，这一系列步骤。如果这个时候，存在一个线程直接请求锁，可能就避开挂起到恢复Runnable状态的这段消耗，所以性能更优化。1234567/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125; 默认状态，使用的ReentrantLock()就是非公平锁。再参考如下代码，我们知道ReentrantLock的获取锁的操作是通过装饰模式代理给sync的。 1234567891011121314151617/** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */public void lock() &#123; sync.lock();&#125; 下面参考一下FairSync和NonfairSync对lock方法的实现： 12345678910111213141516171819202122232425/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125;&#125;/** * Sync object for fair locks */static final class FairSync extends Sync &#123; final void lock() &#123; acquire(1); &#125;&#125; 当使用非公平锁的时候，会立刻尝试配置状态，成功了就会插队执行，失败了就会和公平锁的机制一样，调用acquire()方法，以排他的方式来获取锁，成功了立刻返回，否则将线程加入队列，知道成功调用为止。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>公平锁</tag>
        <tag>非公平锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Mac和Windows上同时写Hexo博客？]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%A6%82%E4%BD%95%E5%9C%A8mac%E5%92%8CWindows%E4%B8%8A%E5%90%8C%E6%97%B6%E5%86%99hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先，我是在公司上的windows机器上部署了hexo，但是回家后发现很不方便，家里的电脑是mac机。所以根据网上的经验我总结了一下如何在mac和Windows上同时写hexo博客。 Windows机器这是我在公司的机器，本来以为不同系统会很麻烦，弄完发现一点也不麻烦。 在github上新建远程仓库将原来的page项目删除，新建一个和原来名字一样的空项目。不用初始化README.md 此时只有一个空的master分支。 本地初始化一个Hexo项目注意：本地的目录不要动 重新新建一个空目录，作为你的博客目录。进入该目录，右击Git bash here，初始化一个Hexo项目：123hexo initnpm installnpm install hexo-deployer-git --save 然后用自己原来博客里的文件替换掉这里的source\, scaffolds\, themes\,_config.yml替换成自己原来博客里的。 注意，这里把themes/next中的.git/目录删除 将整个目录推送到master要推送到master分支，首先要将该目录初始化为本地Git仓库： 123456git init//把博客目录下所有文件推送到master分支git remote add origin xxgit add .git commit -m &quot;first add hexo source code&quot;git push origin master 注意：如果不小心初始化了README.md 在执行 git push origin master 会失败.。此时先执行以下命令进行代码合并 1git push origin master 在github上新建一个分支1.创建本地分支 git branch 分支名，例如：git branch hexo 2.切换本地分支 git checkout 分支名，例如从master切换到分支：git checkout hexo 3.远程分支就是本地分支push到服务器上。比如master就是一个最典型的远程分支（默认）。 git push origin hexo 4.设置默认分支 git branch --set-upstream-to=origin/hexo hexo 新建一个分支hexo(名字可以自定义)，这时候hexo分支和master分支的内容一样，都是hexo的源文件。并把hexo设为默认分支，这样的话在另外一台机器上克隆下来就直接进入hexo分支，并且以后所有操作都是在hexo分支下完成。 为什么需要这个额外的分支呢？ 因为hexo d只把静态网页文件部署到master分支上，所以你换了另外一台电脑，就无法pull下来继续写博客了。有了hexo分支的话，就可以把hexo分支中的源文件(配置文件、主题样式等)pull下来，再hexo g的话就可以生成一模一样的静态文件了 部署博客还是和以前一样： 1. hexo g -d 如果提示 RROR Deployer not found: git 说明前面 npm install --save hexo-deployer-git 没有执行成功 再执行一次 2. npm install --save hexo-deployer-git 博客已经成功部署到master分支，这时候到github查看两个分支的内容，hexo分支里是源文件，master里是静态文件 注意：根目录下的_config.yml配置文件中branch一定要填master，否则hexo d就会部署到hexo分支下。 关联到远程hexo分支如果有修改的话 ,在本地新建一个hexo分支别忘了，要推送到hexo分支上去： git add . git commit -m &quot;&quot; git push origin hexo 这样才能在另外的机器上pull下来，保持同步 MAC机器个人PC上的工作已经完成了，下面讲一下如果你换到了另外一台电脑上，应该如何操作。 将博客项目克隆下来git clone xxx 克隆下来的仓库可能是master分支（我已经设置hexo为默认分支了 但是clone下来还是master分支）这时候需要切换一下分支，所以可以在这基础上继续写博客了。 #查看所有分支 git branch -a #切换分支 git checkout hexo 但是由于.gitignore文件中过滤了node_modules\，所以克隆下来的目录里没有node_modules\，这是hexo所需要的组件，所以要在该目录中重新安装hexo，但不需要hexo init。 npm install hexo npm install npm install hexo-deployer-git --save 新建一篇文章测试hexo g -d 推送到hexo分支git add . git commit -m &quot;add work PC test&quot; git push origin hexo 部署到master分支hexo g -d 日常操作如果上面的过程都操作无误的话，你就可以在任何能联网的电脑上写博客啦。一般写博客的流程是下面这样。 写博客前不管你本地的仓库是否是最新的，都先pull一下，以防万一： git pull origin hexo 把最新的pull下来，再开始撰写新的博客。 写博客hexo new “title”然后打开source/_posts/title.md，撰写博文。 写完博客先推送到hexo分支上： git add . git commit -m &quot;add article xxx&quot; git push origin hexo 最后部署到master分支上hexo g -d 整个流程大概就是这样。 再次回到Windows机器等我再次回到Windows机器上的时候,我git pull下最新的代码,但是提示我如下错误 $ hexo g ERROR Local hexo not found in E:\Hexo ERROR Try running: &apos;npm install hexo --save&apos; 这个时候你需要:1.删除node_modules文件夹2.执行一下代码 npm install 然后在执行 hexo g -d 3.原因 .gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

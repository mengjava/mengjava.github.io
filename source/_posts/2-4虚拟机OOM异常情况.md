---
title: 2-4虚拟机OOM异常情况
date: 2019-03-31 17:29:39
categories: 
- JVM读书笔记
tags:
- Java内存溢出
---
## 1 Java堆溢出

首先分析清除到底是出现了内存泄露还是内存溢出

如果是内存泄露,可进一步通过工具查看泄露对象到GC Roots的引用链.找到泄露对象和GC Roots的关联,是怎么导致泄露对象无法自动回收的.通过泄露对象的类型信息和GC Roots引用链的信息.准确定位到泄露代码的位置。
如果不存在泄露，检查虚拟机参数（-Xmx和-Xms），与机器物理内存对比看是否还可以调大。
<!--more-->
## 2 虚拟机栈和本地方法栈溢出

栈容量只由-Xss参数设置。
两种异常：
* a 线程请求的栈深度大于虚拟机允许的最大深度，将抛出SOE异常。
在单线程程序的操作中，无论栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候都会抛出SOE异常

* b 虚拟机在扩展的时候无法申请到足够的内存空间，则会抛出OOM异常（解决方法 减小栈帧的内存）。
在多线程的情况下，不断创建线程可以产生OOM，-Xss的参数越大，创建的线程数量自然就越少，创建线程的时候越容易把内存耗尽。

## 3 方法区和运行时常量池溢出
使用String。intern（）无限添加字符串到常量池中。
String.intern()作用:如果字符串常量池已经包含了一个等于此String对象的字符串,最返回代表池中这个字符串的String 对象.否则将此String对象包含的字符串添加到常量池中,并返回代表池中这个字符串的STring对象。

J**DK1.6和JDK1.7 string.intern()的区别**

JDK1.6中,intern()方法会把首次遇到的字符串实例复制到永久代中,返回永久代中这个字符串实例的引用;
JDK1.7中,intern()实现不会复制实例,只是在常量池中记录首次出现的实例引用,因此intern()返回堆中这个字符串实例引用.


## 4 本机直接内存溢出

directMemory(直接内存)容量可以通过-XX: MaxDirectMemorySize指定,如果不指定,默认和Java堆最大值(-Xmx)一样。


 
 




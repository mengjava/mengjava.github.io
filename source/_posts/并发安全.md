---
title: 并发安全
date: 2019-05-19 11:18:10
categories: 
- 课堂整理笔记
tags:
- 并发
---

### 什么是并发安全
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称为这个类时是线程安全的。
<--more-->

### 线程封闭
避免并发最简单的方法就是线程封闭。就是把对象封装到线程里，只有这个线程能看到此对象。那么这个对象就算不是线程安全的也不会出现任何安全问题。

**实现线程封闭的方法：**
* ad-hoc 线程封闭：这个完全靠实现者控制的线程封闭，他的线程封闭完全靠实现者实现。
**栈封闭**
* 栈封闭：简单来说栈封闭就是局部变量。多个线程访问一个方法，此方法中的局部变量都会被拷贝一份到线程栈中。所以局部变量不是被多个线程所共享的，也就不会出现并发问题。

### 无状态的类
没有任何成员变量的类就是无状态类，这个种类一定是线程安全的。


### 让类不可变
让类不可变有两种方式：
* 1 加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的泪也要是不可变，才能够保证整个类是不可变的。

* 2 根本就不提供任何可供修改的成员变量的地方，同时成员变量也不作为方法的返回值。


### 加锁和CAS
最常见的线程安全的手段，使用synchronized关键字，使用显示锁，使用各种原子变量，修改数据时使用CAS机制等等。


### 安全的发布
类中持有的成员变量，如果基本类型发布出去，并没有关系，因为发布出去的是一个变量的副本。但是类中持有的成员变量是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从个人造成整个线程类线程不安全的问题。


### TheadLocal
TheadLocal是实现线程封闭最好方法。ThreadLocal内部维护一个Map，Map的key是每个线程的名称，而Map的值就是我们要封闭的对象。每个线程中对象都对应着Map中一个值，也就是ThreadLocal利用Map实现了对象的线程封闭。

### Servlet辨析
Servlet不是线程安全的类：
1 在需求上，很少有共享的需求
2 接收到了请求，返回应答的时候，一般都是由一个线程来负责的。
但是只要Servlet中有成员变量，一旦有多个线程的写，就很容易产生线程安全问题。




### 死锁
是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。

#### 学术化的定义
死锁的发生必须具备以下四个必要条件：

1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，•••，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

#### 现象、危害和解决
在我们IT世界有没有存在死锁的情况，有：数据库里多事务而且要同时操作多个表的情况下。所以数据库设计的时候就考虑到了检测死锁和从死锁中恢复的机制。比如oracle提供了检测和处理死锁的语句，而mysql也提供了“循环依赖检测的机制”

**现象：**
简单顺序死锁：一眼就能看出来
动态顺序死锁：动态的顺序可能导致的死锁。

**危害：**
1.线程不工作。
2.没有任何的异常信息可以提供我们检查。
3.一旦程序发生了死锁，是没有任何的办法恢复的，只能重启程序，对生产平台的程序来说，这个是很严重的问题；测试也不好发现。

**解决**
1. 定位
通过jps查询应用的id，再通过jstack id查看应用的锁的持有情况
2. 修正
关键是保证那锁的顺序一致性
两种解决方法：
a 内部通过顺序比较，确定拿锁的顺序；
b 采用尝试拿锁的机制。

### 其他安全问题
**活锁**
两个线程尝试拿锁的机制中，发生了多个线程相互谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。
解决办法：每个线程休眠随机数，错开拿锁的时间。

**线程饥饿**
低优先级的线程，总是拿不到执行时间

### 并发下的性能
使用并发的目标是为了提高性能，引入多线程后，其实会引入额外的开销，如线程之间的协调、增加的上下文切换，线程的创建和销毁，线程的调度等等。过度的使用和不恰当的使用，会导致多线程程序甚至比单线程还要低。

衡量应用的程序的性能：服务时间，延迟时间，吞吐量，可伸缩性等等，其中服务时间，延迟时间（多快），吞吐量（处理能力的指标，完成工作的多少）。多快和多少，完全独立，甚至是相互矛盾的。


### 线程引入的开销

1 上下文切换
2 内存同步
同步操作的性能开销包括多个方面。在 synchronized和 volatile提供的可见性保证中可能会使用一些特殊指令,即内存栅栏( Memory Barrier)。
内存栅栏可以刷新缓存,使缓存无效刷新硬件的写缓冲,以及停止执行管道。
内存栅栏可能同样会对性能带来间接的影响,因为它

3 阻塞
引起阻塞的原因：包括阻塞IO,等待获取发生竞争的锁,或者在条件变量上等待等等。

### 如何减少锁的竞争
1 减少锁的粒度
使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁

2 缩小锁的范围
对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作

3 避免多余的锁
两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化—扩大锁的范围。

4 锁分段
ConcurrrentHashMap就是典型的锁分段。

5 替换独占锁 
在业务允许的情况下：
1、	使用读写锁，
2、	用自旋CAS
3、使用系统的并发容器

---
title: 3.4 内存分配和回收策略
date: 2019-04-01 11:31:24
categories: 
- JVM读书笔记
tags:
- 内存分配和回收策略
---

## 1 对象优先在eden分配
大部分情况下,兑现在新生代Eden区分配.当Eden区域没有足够空间进行分配，虚拟机发起一次Minor GC。
* 新生代GC（Minor GC）:指发生在新生代的垃圾收集动作,Moinor GC发生非常频繁,一般回收速度比较快。
* 老年代GC（Major GC/Full GC):指在老年代发生的GC。
<!--more-->
## 2 大对象直接进入老年代
所谓大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串数组。
虚拟机提供了一个-XX：pretenureSizeThreshold参数，大于这个设置的值直接进入老年代。这也做避免Eden区及Survivor区之间发生大量的内存复制。

## 3 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活,并能被Survivor容纳的话,将被移动Survivor空间，年龄设置为1。每发生一次Minor GC 年龄增加一岁。当年龄增加到15岁（默认值）将会晋升到老年代。年龄参数可以通过-XX:MaxTenuringThreshold设置。

## ４动态对象年龄判断
虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold,如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一般,那么年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到MaxTenuringThreshold中要求的年龄。

## 5 空间分配担保

在发生Minor GC之前,会先检查老年代最大的连续空间是否大于新生代所有对象空间总和,如果条件成立,那么MinorGc才是安全的。如果不成立，则虚拟机查看HandlePromotionFailure设置是否允许担保失败。如果允许，那么查看老年代最大可用连续空间是否大于历次晋升到老年代的平均值，若果大于则则尝试进行一次MinorGC（这次MinorGC是有风险的）。如果设置成不允许冒险,则进行一次Full GC。
<u>**JDK6之后不在使用HandlePromotionFailure参数，只要老年代连续空间大于新生代空间的总和或历次晋升的平均大小就进行Minor GC，否则进行Full GC。**</u>

 **冒险的含义**：
> 新生代使用复制收集算法,但是为了内存利用率,只是用Survior空间来轮换备份,因此当出现大量的对象在Minor GC后仍然存活(极端情况下为内存回收后新生代中所有对象都存活)，此时就需要老年代来担保，把Survior无法容纳的对象直接放入老年代。前提是来年代本身有容纳那些对象的剩余空间。因此取之前每一次回收晋升到老年代对象容量的平均值作为经验值，与老年代剩余空间做比价，决定是否需要进行Full GC来让老年代腾出更多的空间。




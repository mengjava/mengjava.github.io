---
title: 3.1 对象已死了吗
date: 2019-04-01 11:30:29
categories: 
- JVM读书笔记
tags:
- 对象存活分析算法
---


## 1 引用计数法
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；
当引用失效的时候计数器减一；
**缺点：** 很难解决对象相互循环引用的问题。
<!--more-->
## 2.可达性分析算法

通过一系列的称为“GC Roots”的对象作为起始点，从这个节点开始往下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots对象没有任何引用链相连时，则证明此对象是不可用的，所以他们将会被判定为可回收对象。

在Java语言中，可作为GC Roots的对象包括下面几种：
* a 虚拟机栈（战阵中的本地变量表）中引用的对象。
* b 方法区中静态属性引用对象。
* c 方法去中常量引用的对象。
* d 本地方法栈中JNI（一般说的是Native）引用的对象。

**引用**
JDK1.2之后 Java分为4种 强引用 软引用 若引用 虚引用

**拯救对象**
一个对象死亡最少要经历两次标记过程
**第一次**：发现与GC Roots没有引用链，进行标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。对象没有覆盖finalize（）方法或finalize()方法已经执行过了,视为没必要执行。
**第二次**：被判定为必须执行finalize()方法的对象,将此对象放入到一个F-Queue的队列之中,稍后GC将对这个队列里的对象进行二次标记.如果对象在finalize()中成功拯救自己,只要重新与引用链上的任何对象建立关联即可。此时它将会呗移出“即将回收”的集合。
finalize()方法只会被执行一次。



 **回收方法区**
方法区的垃圾收集主要回收两部门内容 废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。

废弃常量：没有任何对象引用即为废弃常量。
无用类：

   * a 该类所有实例都已经被回收。
   * b 加载该类的ClassLoader已经被回收。
   * c 该类对应的java.lang.Class 对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法。
		
**是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。**





---
title: 5.1案例分析
date: 2019-04-01 11:32:00
categories: 
- JVM读书笔记
tags:
- 案例分析
---
## 1 高性能硬件上的程序部署策略
在高性能硬件上部署程序，目前主要有两种方式：
 ### **通过64位JDK来使用大内存**
> 使用这种方法要考虑一下问题:
> * 内存收回导致的长时间停顿
> * 现阶段,64位JDK的性能测试普遍低于32位JDK.
> * 需要保证程序足够稳定,因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产十几个GB仍至更大的Dump文件),即使生成了快照也几乎无法分析。
> * 相同程序在64位JDK消耗的内存一般比32位JDK大,这是由于指针膨胀,以及数据类型对齐补白等因素导致的。 
<!--more-->

 ### 使用若干个32位虚拟机加你了逻辑集群来利用硬件资源
 
具体做法是在一台物理机上启动多个应用服务器进程,每个服务器进程分配不同端口,然后在前端搭建一个负载均衡器,以反向代理的方式来分配访问请求。
使用逻辑集群部署程序会遇到一下问题：
> * 尽量避免节点竞争全局资源，例如各个节点同时访问某个磁盘文件，很容易导致IO异常。
> * 很难最高效的利用某些资源池，譬如连接池。
> * 各个节点仍然不可避免地受到32位的内存限制（32位Windows平台每个进程只能使用2GB的内存）。
> * 大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用。

## 2 集群间同步导致的内存溢出

使用全局缓存，服务多次出现内存溢出问题
> 首先让服务带着 -XX：+HeapDumpOnOutOfMemoryError参数运行一段时间，查看heapdump文件，发现有大量的org.jgroups.protocols.pbcast.NAKACK对象。发现是信息传输失败需要重发，重发数据在内存中不断堆积，很快产生了内存异常。这个缺陷是由于JBossCacache的缺陷导致的。

## 3 堆外内存导致的溢出错误

![5.1.png](https://i.loli.net/2019/04/01/5ca18961a0580.png)


## 4 外部命令导致系统缓慢

每个用户请求的处理都需要执行一个外部shell脚本来获取系统的一些信息。执行shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的,这种方式调用会克隆一个和当前虚拟机拥有一样环境变量的进程,如果频繁执行这个操作,系统的消耗很大,内存负担很重。


## 5 服务器JVM进程崩溃

![5.2.png](https://i.loli.net/2019/04/01/5ca18961ab6e7.png)



## 6 由Windows虚拟机内存导致的长时间停顿

长时间停顿首先加入参数-XX:+PrintGCApplicationStoppedTIme -XX:+printGCDateStamps -Xloggc:gclog.log后,从GC日志中确认停顿确实有GC导致的，偶尔会出现接近一分钟的GC。
![5.3.png](https://i.loli.net/2019/04/01/5ca189615dd23.png)


主要原因是GUI程序内存变化的一个特点，当它最小化的时候，资源管理器显示的占用内存大幅度减小，但是虚拟机内存没有变化，因此怀疑程序在最小化时他的工作内容被自动交换到自盘的页面文件之中了，这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿。解决办法就是加入-Dsun.awt.keepWorkingSetOnMinimize=tru参数来解决。这个参数保证程序在恢复最小化时能够立即响应。





---
title: 3.3 垃圾收集器
date: 2019-04-01 11:30:56
categories: 
- JVM读书笔记
tags:
- 垃圾收集器
---
## Serial 收集器（新生代）
这是一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，进行垃圾收集时，必须暂停其他所有的工作线程。
**实际使用场景**：依然是虚拟机运行在Client模式下的默认新生代收集器。例如 用户桌面应用场景中，分配给虚拟机管理的内存不会很大，停顿时间在几十毫秒最多一百多毫秒以内，这点停顿是可以接受的。
**优点**：简单高效，对于限定CPU的环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集。
<!--more-->
## ParNew 收集器（新生代）
ParNew收集器是Serial收集器的多线程版本,除了使用多线程进行垃圾收集之外,其余行为包括Serial收集器可用的所有控制参数、收集算法、对象分配规则、回收策略等都和Serial收集器完全一样。
**实际使用场景**：Server模式下的虚拟机中首选的新生代收集器。因为除了Serial收集器外，目前只有它可以与CMS收集器配合工作。Parallel Scavenge收集器无法和CMS配合工作。
* **-XX:+UseConcMarkSweepGc** :ParNew收集器也是使用此配置的默认新生代收集器
* **-XX:+UserParNewGC**: 此配置强制使用ParNew收集器为新生代收集器
* **-XX:ParallelGCThreads**:参数来限制垃圾收集器的线程数。

## Parallel Scavenge 收集器(新生代)
使用复制算法并且多线程的收集器，和ParNew类似。
**特点**：Parallel Scavenge收集器的目标是达到一个可控的吞吐量。
**吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)**
自适应调节策略:-XX:+UseAdaptivePolicy 这个参数打开后,不需要手工指定对象年龄等参数细节,动态调整这些参数提供最合适的停顿时间和最大吞吐量。

## Serial Old收集器（老年代）
单线程收集器 使用标记标记-整理算法，主要用于Client模式下的虚拟机使用。

## Parallel Old 收集器（老年代）
多线程使用“标记-整理”短发。JDK1.6中才开始提供。配合Parallel Scavenge使用。

## CMS收集器
是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现。一共分为四个步骤
* 初始标记 
* 并发标记
* 重新标记（为了修正并发标记期间因用户程序继续运行而导致而导致标记产生变动的那一部分对象的标记记录）
* 并发清除

缺点：
   *   CMS收集器对CPU资源非常敏感。CMS默认启动的回收线程数是（CPU数量+3）/4,当CPU在4个以上时,并发回收时垃圾手机线程不少于25%的CPU资源,但是当小于4时,CMS对用户的影响就变得更大,影响用户使用。
   
   * CMS无法处理浮动垃圾可能会出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。浮动垃圾就是并发清除的时候产生的垃圾。
   
   * 基于“标记-清除”算法那实现的收集器，结束后会产生大量空间碎片。碎片过多会导致即使老年代即使还有很大空间剩余，但是找不到连续的空间，还是会触发Full GC。为了解决这个问题CMS提供了-XX:+UseCMSCompactAtFullConllection开关参数,用于在FullGC时开启内存碎片的合并整理。


## G1收集器
是当今收集器技术发展的最前沿成果之一，G1收集器把整个Java堆划分为多个大小相等的独立区域（Region）,新生代和老年代不再是隔离的。

特点:
* **并行和并发**: G1充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短停顿时间。
* **分代收集**:G1可以不需要其他收集器配合就可以独立管理整个GC堆。
* **空间整合**：基于标记整理算法，从局部上（两个Region之间）是基于复制算法，两种算法都意味着G1运作期间不会产生内存空间碎片。
* **可预测的停顿**：G1追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确之情在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N秒。
**可预测停顿原因**：G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个有限列表，每一个根据时间，优先回收价值最大的Region。






---
title: 第3章 高级装配
date: 2019-05-26 10:34:12
- Spring实战读书笔记
tags:
- 高级装配
---
---

### 3.1 环境与profile
#### 3.1.1 配置profile bean

在3.1版本中，Spring引入了bean profile的功能。要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署到每个环境时，要确保对应的profile处于激活（active）的状态。

在Java配置中，可以使用@Profile注解指定某个bean属于哪一个profile。例如：@Profile("dev")。
@Profile注解应用在类级别上，如果dev profile没有激活的话,那么带有@Bean注解的方法都会被忽略掉。

**在Spring3.1中，只能在类级别上使用@Profile注解，但是，从Spring3.2开始，你也可以在方法级别上使用@Profile注解。
没有指定profile的bean始终都会被创建，与激活哪个profile没有关系。**

#####  在XML中配置profile

 我们也可以通过<beans>元素的profile属性， 在XML中配置profile bean。

![TIM截图20190520135143.png](https://i.loli.net/2019/05/20/5ce2408bd14fd59156.png)

同时可以在根<beans>元素中嵌套定义<beans>元素，而不是每个环境都创建一个profile XML文件。这能将所有的profile bean定义放到同一个XML文件中。

![配置多个profile.png](https://i.loli.net/2019/05/20/5ce242bba79b957727.png)


#### 3.1.2 激活profile

Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active和spring.profile.default。

**如果设置了spring.profiles.active属性的话， 那么它的值就会用来确定哪个profile是激活的。 但如果没有设置spring.profiles.active
属性的话， 那Spring将会查找spring.profiles.default的值。如果spring.profiles.active和spring.profiles.default均没有设置的话， 那就没有激活的profile， 因此只会创建那些没有定义在profile中的bean。**


 有多种方式来设置这两个属性：
 
 *  作为DispatcherServlet的初始化参数；

*  作为Web应用的上下文参数；

*  作为JNDI条目；

*  作为环境变量；

*  作为JVM的系统属性；

*  在集成测试类上， 使用@ActiveProfiles注解设置。


 Spring提供了@ActiveProfiles注解， 我们可以使用它来指定运行测试时要激活哪个profile。 在集成测试时， 通常想要激活的是开发环
境的profile。 例如， 下面的测试类片段展现了使用@ActiveProfiles激活dev profile：
@ActiveProfiles("dev")


### 3.2 条件化的bean
假设你希望一个或多个bean只有在应用的类路径下包含特定的类库时才创建.或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。

Spring4之前，很难实现这种级别的条件化配置，但是Spring4引入了一个新的@Condition注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。

@Conditional中给定了一个Class， 它指明了条件， 设置给@Conditional的类可以是任意实现了Condition接口的类型。 可以看出来， 这个接口实现起来很简单直接， 只需提供matches()方法的实现即可。 如果matches()方法返回true， 那么就会创建带有@Conditional注解的bean。 如果matches()方法返回false， 将不会创建这些bean。


 **在Spring 4中， @Profile是如何实现的**
  从Spring 4开始， @Profile注解进行了重构， 使其基于@Conditional和Condition实现。

 
![Profile注解详解.png](https://i.loli.net/2019/05/20/5ce258965448a75110.png)

### 3.2 处理自动装配的歧义
 仅有一个bean匹配所需的结果时， 自动装配才是有效的。 如果不仅有一个bean能够匹配结果的话， 这种歧义性会阻碍Spring自动装
配属性、 构造器参数或方法参数。

当确实发生歧义性的时候， Spring提供了多种可选方案来解决这样的问题。 你可以将可选bean中的某一个设为首选（primary） 的
bean， 或者使用限定符（qualifier） 来帮助Spring将可选的bean的范围缩小到只有一个bean。


#### 3.3.1 标示首选的bean

 在声明bean的时候， 通过将其中一个可选的bean设置为首选（primary） bean能够避免自动装配时的歧义性。 当遇到歧义性的时
候， Spring将会使用首选的bean， 而不是其他可选的bean。 实际上，你所声明就是“最喜欢”的bean。

 在Spring中， 可以通过@Primary来表达最喜欢的方案。 @Primary能够与@Component组合用在组件
扫描的bean上， 也可以与@Bean组合用在Java配置的bean声明中。 比如， 下面的代码展现了如何将@Component注解的IceCream 
bean声明为首选的bean：

```java
@Component
@Primary
public class IceCream implements Dessert {....}
```
或者,如果你通过Java配置显示地声明IceCream,那么@Bean方法应该如下所示:
```java
@Bean
@Primary
public Dessert iceCream(){
    return new IceCream();
}
```


 如果你使用XML配置bean的话， 同样可以实现这样的功能。<bean>元素有一个primary属性用来指定首选的bean：
```java
<bean id="iceCream" class="com.deserteater.IceCream" primary="true">
```


#### 3.3.2 限定自动装配的bean

Spring的限定符能够在所有可选的bean上进行缩小范围的操作， 最终能够达到只有一个bean满足所规定的限制条件。 如果将所有的限定符都用上后依然存在歧义性， 那么你可以继续使用更多的限定符来缩小选择范围。

 @Qualifier注解是使用限定符的主要方式。 它可以与@Autowired和@Inject协同使用， 在注入的时候指定想要注入进去的是哪个
bean。 例如， 我们想要确保要将IceCream注入到setDessert()之中：

```java
@Autowired
@Qualifier("iceCream")
public void setDessert(Dessert dessert){
    this.dessert = dessert;
}
```

 如果你重构了IceCream类， 将其重命名为Gelato的话， 那此时会发生什么情况呢？ 如果这样的话， bean的ID和默认的限定符会变
为gelato， 这就无法匹配setDessert()方法中的限定符。 自动装配会失败。

**创建自定义的限定符**

 我们可以为bean设置自己的限定符， 而不是依赖于将bean ID作为限定符。 在这里所需要做的就是在bean声明上添加@Qualifier注解。 
例如， 它可以与@Component组合使用， 如下所示：
```java
@Component
@Qualifier("cold")
public vlass IceCream implements Dessert{....}
```

**使用自定义的限定符注解**
 通过声明自定义的限定符注解， 我们可以同时使用多个限定符， 不会再有Java编译器的限制或错误。 与此同时， 相对于使用原始的
@Qualifier并借助String类型来指定限定符， 自定义的注解也更为类型安全。


### 3.4 bean的作用域
在默认情况下，Spring应用上下文中所有bean都是作为以单例(singleton)的形式创建的。也就是说不管给定的一个bean被注入到其他bean多少次，每次所有注入的都是同一个实例。

有时候，可能会发现，你所使用的类是易变的，它们会保持一些状态，因此重用是不安全的，在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。

Spring定义了多种作用域，可以基于这些作用域创建bean，包括：
* 单例（singleton）：在整个应用中，只创建bean的一个实例。
* 原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。
* 会话（Session）：在Web应用中，为每个会话创建一个bean实例。
* 请求（Request）；在Web应用中，为每个请求创建一个bean实例。

如果选择其他的作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用。

**@Component或@Bean区别**
> 首先我们看看这两个注解的作用：
@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。
@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。
而@Bean的用途则更加灵活
**当我们引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现**

例如：
```java
public class WireThirdLibClass {
    @Bean
    public ThirdLibClass getThirdLibClass() {
        return new ThirdLibClass();
    }
}
```


**例如，如果你使用组件扫描来发现和声明bean，那么你可以在bean的类上使用@Scope注解，将其声明为原型bean：**
```java
@Component
@Scope（ConfigurableBeanFactory.SCOPE_PROTOTYPE）
public class Notepad {...}
```

如果使用@bean注解
```java
@bean
@Scope（ConfigurableBeanFactory.SCOPE_PROTOTYPE）
public class Notepad {
 return new Notepad();
}
```

**如果使用XML来配置，可以使用<bean>元素的scope属性来设置作用域**

```java
<bean id="notepad" class="com.myapp.Notepad" scope="prtotype">
```



#### 3.4.1 使用会话和请求作用域

 在Web应用中， 如果能够实例化在会话和请求范围内共享的bean， 那将是非常有价值的事情。 例如， 在典型的电子商务应用中， 可能会有一个bean代表用户的购物车。 如果购物车是单例的话， 那么将会导致所有的用户都会向同一个购物车中添加商品。 另一方面， 如果购物车是原型作用域的， 那么在应用中某一个地方往购物车中添加商品， 在应用的另外一个地方可能就不可用了， 因为在这里注入的是另外一个原型作用域的购物车。就购物车bean来说， 会话作用域是最为合适的， 因为它与给定的用户关联性最大。 要指定会话作用域， 我们可以使用@Scope注解， 它的使用方式与指定原型作用域是相同的。
 
 <font color=red>在单例中如果要注入会话/请求作用域的bean 实际上注入的是一个代理作用域，因为当只有进入会话的时候，才会创建真正的bean，代理会对其进行懒解析并调用委托给会话作用域内真正的bean。</font>
 
 如果被代理的是一个具体类的话,Spring就没有办法创建基于接口的代理.此时,它必须使用CGLib来生成基于类的代理。

![作用域代理延迟注入请求.png](https://i.loli.net/2019/05/22/5ce4c632e08c839682.png)


#### 3.4.2 在XML中声明作用域代理

如果使用XML来声明会话或请求作用域的bean，那么就不能使用@Scope注解及其proxyMode属性了。<bean>元素的scope属性能够设置bean的作用域,但是该怎样指定代理模式呢。

要设置代理模式，我们需要使用Spring aop命名空间的一个新元素：

```java
<bean id="cat" class="com.myapp.ShoppingCart" scope="session">
    <aop:scoped-proxy/>
 </bean>
```
<aop:scoped-proxy>是与@Scope注解的proxyMode属性功能相同的Spring XML配置元素。它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLib创建目标类的代理。 但是我们也可以将proxy-target-class属性设置为false， 进而要求它生成基于接口的代理：

```java
<bean id="cat" class="com.myapp.ShoppingCart" scope="session">
    <aop:scoped-proxy proxy-target-class"false" />
 </bean>
```
如果使用<aop:scoped-proxy>元素,我么那必须在XML配置中声明Spring的aop命名空间:

![Spring aop命名空间.png](https://i.loli.net/2019/05/22/5ce4eae3ad19612468.png)

### 3.5 运行时值注入

当讨论依赖注入的时候,我们通常所讨论的是将一个bean引用注入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象进行关联。

为了避免硬编码值，Spring提供了两种在运行时求值的方式：
* 属性占位符
* Spring表达式语言(SpEL)

#### 3.5.1 注入外部值

在Spring中，处理外部值的最简单方式就是声明属性源并通过Spring的Envireonment来检索属性。
这个属性文件会加载到Spring的Environment中，稍后可以从这里检索属性。

**解析属性占位符**
Spring一直支持将属性定义到外部的属性的文件中，并使用占位符值将其插入到Spring bean中。在Spring装配中，占位符的形式为使用“${...}"包装的属性名称。为了使用占位符，我们必须要配置一个PropertyPlaceholderConfigurer bean 或 PropertySourcesPlaceholderConfigurer。从Spring 3.1 开始，推荐使用PropertyPlaceholderConfigurer bean，因为它能够基于Spring Environment及其属性源来解析占位符。

解析外部属性能够将值得处理推迟到运行时，但是它的关注点在于根据名称来自于Spring Environment 和属性源的属性。而Spring表达式语言提供了一种更通常的方式运行方式在运行时计算所要注入的值。



#### 3.5.2 使用Spring表达式语言进行装配

Spring 3 引入了Spring表达式语言（Spring Expression Language，SpEl），它能够以一种强大和简洁的方式将值装配到bean属性和构造器参数中，在这个过程中所使用的表达式会在运行时计算得到值。使用SpEl，你可以实现超乎想象的装配效果，这是使用其他的装配技术难以做到的。

SpEl拥有很多特性，包括：
* 使用bean的ID来引用bean；
* 调用方法和访问对象的属性；
* 对值进行算术，关系和逻辑运算；
* 正则表达匹配；
* 集合操作；

**SpEl样例**
SpEl表达式要放到“#{...}”之中，这与属性占位符有些类似，属性占位符需要放到“${...}”之中。下面所展现的可能是最简单的SpEl表达了：#{1}

#{T(System).currentTimeMillis()}:计算表达式的那一刻到当前时间到毫秒数。
#{stPeppers.artist}:调用ID为sgtPeppers的bean的artist属性
#{systemProperties['disc.titile']}:引用系统属性


**表达字面值**
#{3.1415}
#{9.878E4}
#{'Hello'}
#{false}

**引用bean、属性和方法**
SpEl所能做的另外一件基础的事情就是通过ID引用其他的bean。

#{sgtPeppers}:引用bean
#{artistSelector.selectArtist()}：引用方法


**在表达式中使用类型**

如果要在SpEL中访问类作用域的方法和常量的话，要依赖T()这个关键的运算符。
T{java.lang.Math}:使用Java的Math类。
T()运算符真正价值在于它能够访问目标类型的静态方法和常量。


**SpEl运算符**
SpEl提供了多个运算符 算术运算、比较运算、逻辑运算、条件运算、正则表达式。










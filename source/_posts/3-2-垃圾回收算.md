---
title: 3.2 垃圾回收算
date: 2019-04-01 11:30:47
categories: 
- JVM读书笔记
tags:
- 垃圾回收算法
---



## 1 标记-清除算法（老年代）

标记：标记出所有需要回收的对象，在标记完成后同意回收所有被标记的对象。
清除：回收对象
<!--more-->
不足：
    a 标记和清除两个过程的效率都不高；
    b 标记清除之后产生大量的不连续内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收。
	  
## 2 复制算法（新生代）

 为了解决效率问题 内存按照容量划分为大小相等的两块，每次使用其中的一块。一块用完了 就将还存活的对象移动到另一端，然后再把已经使用过的内存空间一次清理掉。
 优点:每次都对半个区域进行内存回收,无需考虑内存碎片等复杂情况。
 
 不按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收的时候把Eden和survivor上存活的对象一次性复制到另一块Survior上。最后清理掉Survivor和Eden空间。Eden和Survivor的大小比例为8:1:1 这样之后10%空间被浪费掉,没办法保证每次只回收不多于10%的对象存活,当Survivor空间不足时,需要依赖其他内存(老年代),进行分配担保。
 
 **老年代不要使用复制算法
 原因**：复制算法在对象存活率较高的时候就要进行较多的复制操作，效率会变低，如果不是按照1:1的比例,就需要额外的空间担保,应对对象100存活的极端情况。
 
##  3 标记整理（老年代）
 和标记-清除一样，后续步骤不是直接对可回收对象进行清除，而是让存活对象移动到另一端，进行整理，另一端的内存进行清除。 